<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Active Record Query Interface â€” Ruby on Rails Guides</title>
<link rel="stylesheet" type="text/css" href="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/style.css">
<link rel="stylesheet" type="text/css" href="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/print.css" media="print">

<link rel="stylesheet" type="text/css" href="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/shCore.css">
<link rel="stylesheet" type="text/css" href="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/shThemeRailsGuides.css">

<link rel="stylesheet" type="text/css" href="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/fixes.css">

<link href="http://edgeguides.rubyonrails.org/images/favicon.ico" rel="shortcut icon" type="image/x-icon">
</head>
<body class="guide">
  <div>
    <img src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/edge_badge.png" alt="edge-badge" id="edge-badge">
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        More Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="http://rubyonrails.org/">Overview</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/download">Download</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/deploy">Deploy</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">Code</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/screencasts">Screencasts</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/documentation">Documentation</a></li>
        <li class="more-info"><a href="http://rubyonrails.org/community">Community</a></li>
        <li class="more-info"><a href="http://weblog.rubyonrails.org/">Blog</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="http://edgeguides.rubyonrails.org/index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="http://edgeguides.rubyonrails.org/index.html">Home</a></li>
        <li class="guides-index guides-index-large">
          <a href="http://edgeguides.rubyonrails.org/index.html" id="guidesMenu" class="guides-index-item nav-item">Guides Index</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr>
              <dl class="L">
                <dt>Start Here</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/getting_started.html">Getting Started with Rails</a></dd>
                <dt>Models</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/active_record_basics.html">Active Record Basics</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/active_record_migrations.html">Active Record Migrations</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/active_record_validations.html">Active Record Validations</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/active_record_callbacks.html">Active Record Callbacks</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/association_basics.html">Active Record Associations</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/active_record_querying.html">Active Record Query Interface</a></dd>
                <dt>Views</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/form_helpers.html">Action View Form Helpers</a></dd>
                <dt>Controllers</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/action_controller_overview.html">Action Controller Overview</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/routing.html">Rails Routing from the Outside In</a></dd>
              </dl>
              <dl class="R">
                <dt>Digging Deeper</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/active_support_core_extensions.html">Active Support Core Extensions</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/i18n.html">Rails Internationalization API</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/action_mailer_basics.html">Action Mailer Basics</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/active_job_basics.html">Active Job Basics</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/security.html">Securing Rails Applications</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/debugging_rails_applications.html">Debugging Rails Applications</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/configuring.html">Configuring Rails Applications</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/command_line.html">Rails Command Line Tools and Rake Tasks</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/asset_pipeline.html">Asset Pipeline</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/working_with_javascript_in_rails.html">Working with JavaScript in Rails</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/autoloading_and_reloading_constants.html">Autoloading and Reloading Constants</a></dd>
                <dt>Extending Rails</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/rails_on_rack.html">Rails on Rack</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/generators.html">Creating and Customizing Rails Generators</a></dd>
                <dt>Contributing to Ruby on Rails</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>
                <dt>Maintenance Policy</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/maintenance_policy.html">Maintenance Policy</a></dd>
                <dt>Release Notes</dt>
                <dd><a href="http://edgeguides.rubyonrails.org/upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/4_2_release_notes.html">Ruby on Rails 4.2 Release Notes</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/4_1_release_notes.html">Ruby on Rails 4.1 Release Notes</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/4_0_release_notes.html">Ruby on Rails 4.0 Release Notes</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/3_2_release_notes.html">Ruby on Rails 3.2 Release Notes</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/3_1_release_notes.html">Ruby on Rails 3.1 Release Notes</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</a></dd>
                <dd><a href="http://edgeguides.rubyonrails.org/2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</a></dd>
              </dl>
          </div>
        </li>
        <li><a class="nav-item" href="http://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html">Contribute</a></li>
        <li><a class="nav-item" href="http://edgeguides.rubyonrails.org/credits.html">Credits</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">Guides Index</option>
              <optgroup label="Start Here">
                  <option value="getting_started.html">Getting Started with Rails</option>
              </optgroup>
              <optgroup label="Models">
                  <option value="active_record_basics.html">Active Record Basics</option>
                  <option value="active_record_migrations.html">Active Record Migrations</option>
                  <option value="active_record_validations.html">Active Record Validations</option>
                  <option value="active_record_callbacks.html">Active Record Callbacks</option>
                  <option value="association_basics.html">Active Record Associations</option>
                  <option selected="selected" value="active_record_querying.html">Active Record Query Interface</option>
              </optgroup>
              <optgroup label="Views">
                  <option value="layouts_and_rendering.html">Layouts and Rendering in Rails</option>
                  <option value="form_helpers.html">Action View Form Helpers</option>
              </optgroup>
              <optgroup label="Controllers">
                  <option value="action_controller_overview.html">Action Controller Overview</option>
                  <option value="routing.html">Rails Routing from the Outside In</option>
              </optgroup>
              <optgroup label="Digging Deeper">
                  <option value="active_support_core_extensions.html">Active Support Core Extensions</option>
                  <option value="i18n.html">Rails Internationalization API</option>
                  <option value="action_mailer_basics.html">Action Mailer Basics</option>
                  <option value="active_job_basics.html">Active Job Basics</option>
                  <option value="security.html">Securing Rails Applications</option>
                  <option value="debugging_rails_applications.html">Debugging Rails Applications</option>
                  <option value="configuring.html">Configuring Rails Applications</option>
                  <option value="command_line.html">Rails Command Line Tools and Rake Tasks</option>
                  <option value="asset_pipeline.html">Asset Pipeline</option>
                  <option value="working_with_javascript_in_rails.html">Working with JavaScript in Rails</option>
                  <option value="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants</option>
              </optgroup>
              <optgroup label="Extending Rails">
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators</option>
              </optgroup>
              <optgroup label="Contributing to Ruby on Rails">
                  <option value="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</option>
                  <option value="api_documentation_guidelines.html">API Documentation Guidelines</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</option>
              </optgroup>
              <optgroup label="Maintenance Policy">
                  <option value="maintenance_policy.html">Maintenance Policy</option>
              </optgroup>
              <optgroup label="Release Notes">
                  <option value="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</option>
                  <option value="4_2_release_notes.html">Ruby on Rails 4.2 Release Notes</option>
                  <option value="4_1_release_notes.html">Ruby on Rails 4.1 Release Notes</option>
                  <option value="4_0_release_notes.html">Ruby on Rails 4.0 Release Notes</option>
                  <option value="3_2_release_notes.html">Ruby on Rails 3.2 Release Notes</option>
                  <option value="3_1_release_notes.html">Ruby on Rails 3.1 Release Notes</option>
                  <option value="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</option>
                  <option value="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</option>
                  <option value="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide">

  <div id="feature">
    <div class="wrapper">
      <h2>Active Record Query Interface</h2><p>This guide covers different ways to retrieve data from the database using Active Record.</p><p>After reading this guide, you will know:</p>
<ul>
<li>How to find records using a variety of methods and conditions.</li>
<li>How to specify the order, retrieved attributes, grouping, and other properties of the found records.</li>
<li>How to use eager loading to reduce the number of database queries needed for data retrieval.</li>
<li>How to use dynamic finders methods.</li>
<li>How to use method chaining to use multiple ActiveRecord methods together.</li>
<li>How to check for the existence of particular records.</li>
<li>How to perform various calculations on Active Record models.</li>
<li>How to run EXPLAIN on relations.</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/chapters_icon.gif" alt="">Chapters</h3>
            <ol class="chapters">
<li>
<a href="#retrieving-objects-from-the-database">Retrieving Objects from the Database</a>

<ul>
<li><a href="#retrieving-a-single-object">Retrieving a Single Object</a></li>
<li><a href="#retrieving-multiple-objects-in-batches">Retrieving Multiple Objects in Batches</a></li>
</ul>
</li>
<li>
<a href="#conditions">Conditions</a>

<ul>
<li><a href="#pure-string-conditions">Pure String Conditions</a></li>
<li><a href="#array-conditions">Array Conditions</a></li>
<li><a href="#hash-conditions">Hash Conditions</a></li>
<li><a href="#not-conditions">NOT Conditions</a></li>
</ul>
</li>
<li><a href="#ordering">Ordering</a></li>
<li><a href="#selecting-specific-fields">Selecting Specific Fields</a></li>
<li><a href="#limit-and-offset">Limit and Offset</a></li>
<li>
<a href="#group">Group</a>

<ul>
<li><a href="#total-of-grouped-items">Total of grouped items</a></li>
</ul>
</li>
<li><a href="#having">Having</a></li>
<li>
<a href="#overriding-conditions">Overriding Conditions</a>

<ul>
<li><a href="#unscope"><code>unscope</code></a></li>
<li><a href="#only"><code>only</code></a></li>
<li><a href="#reorder"><code>reorder</code></a></li>
<li><a href="#reverse-order"><code>reverse_order</code></a></li>
<li><a href="#rewhere"><code>rewhere</code></a></li>
</ul>
</li>
<li><a href="#null-relation">Null Relation</a></li>
<li><a href="#readonly-objects">Readonly Objects</a></li>
<li>
<a href="#locking-records-for-update">Locking Records for Update</a>

<ul>
<li><a href="#optimistic-locking">Optimistic Locking</a></li>
<li><a href="#pessimistic-locking">Pessimistic Locking</a></li>
</ul>
</li>
<li>
<a href="#joining-tables">Joining Tables</a>

<ul>
<li><a href="#using-a-string-sql-fragment">Using a String SQL Fragment</a></li>
<li><a href="#using-array-hash-of-named-associations">Using Array/Hash of Named Associations</a></li>
<li><a href="#specifying-conditions-on-the-joined-tables">Specifying Conditions on the Joined Tables</a></li>
</ul>
</li>
<li>
<a href="#eager-loading-associations">Eager Loading Associations</a>

<ul>
<li><a href="#eager-loading-multiple-associations">Eager Loading Multiple Associations</a></li>
<li><a href="#specifying-conditions-on-eager-loaded-associations">Specifying Conditions on Eager Loaded Associations</a></li>
</ul>
</li>
<li>
<a href="#scopes">Scopes</a>

<ul>
<li><a href="#passing-in-arguments">Passing in arguments</a></li>
<li><a href="#applying-a-default-scope">Applying a default scope</a></li>
<li><a href="#merging-of-scopes">Merging of scopes</a></li>
<li><a href="#removing-all-scoping">Removing All Scoping</a></li>
</ul>
</li>
<li><a href="#dynamic-finders">Dynamic Finders</a></li>
<li>
<a href="#understanding-the-method-chaining">Understanding The Method Chaining</a>

<ul>
<li><a href="#retrieving-filtered-data-from-multiple-tables">Retrieving filtered data from multiple tables</a></li>
<li><a href="#retrieving-specific-data-from-multiple-tables">Retrieving specific data from multiple tables</a></li>
</ul>
</li>
<li>
<a href="#find-or-build-a-new-object">Find or Build a New Object</a>

<ul>
<li><a href="#find-or-create-by"><code>find_or_create_by</code></a></li>
<li><a href="#find-or-create-by-bang"><code>find_or_create_by!</code></a></li>
<li><a href="#find-or-initialize-by"><code>find_or_initialize_by</code></a></li>
</ul>
</li>
<li>
<a href="#finding-by-sql">Finding by SQL</a>

<ul>
<li><a href="#select-all"><code>select_all</code></a></li>
<li><a href="#pluck"><code>pluck</code></a></li>
<li><a href="#ids"><code>ids</code></a></li>
</ul>
</li>
<li><a href="#existence-of-objects">Existence of Objects</a></li>
<li>
<a href="#calculations">Calculations</a>

<ul>
<li><a href="#count">Count</a></li>
<li><a href="#average">Average</a></li>
<li><a href="#minimum">Minimum</a></li>
<li><a href="#maximum">Maximum</a></li>
<li><a href="#sum">Sum</a></li>
</ul>
</li>
<li>
<a href="#running-explain">Running EXPLAIN</a>

<ul>
<li><a href="#interpreting-explain">Interpreting EXPLAIN</a></li>
</ul>
</li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <p>If you're used to using raw SQL to find database records, 
then you will generally find that there are better ways to carry out the
 same operations in Rails. Active Record insulates you from the need to 
use SQL in most cases.</p><p>Code examples throughout this guide will refer to one or more of the following models:</p><div class="info"><p>All of the following models use <code>id</code> as the primary key, unless specified otherwise.</p></div><div class="code_container">
<div><div id="highlighter_998693" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Client &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_one </code><code class="ruby color2">:address</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_many </code><code class="ruby color2">:orders</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_and_belongs_to_many </code><code class="ruby color2">:roles</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="code_container">
<div><div id="highlighter_40027" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Address &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">belongs_to </code><code class="ruby color2">:client</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="code_container">
<div><div id="highlighter_312336" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Order &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">belongs_to </code><code class="ruby color2">:client</code><code class="ruby plain">, counter_cache: </code><code class="ruby keyword">true</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="code_container">
<div><div id="highlighter_180224" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Role &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_and_belongs_to_many </code><code class="ruby color2">:clients</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Active Record will perform queries on the database for you and is 
compatible with most database systems (MySQL, PostgreSQL and SQLite to 
name a few). Regardless of which database system you're using, the 
Active Record method format will always be the same.</p><h3 id="retrieving-objects-from-the-database">1 Retrieving Objects from the Database</h3><p>To
 retrieve objects from the database, Active Record provides several 
finder methods. Each finder method allows you to pass arguments into it 
to perform certain queries on your database without writing raw SQL.</p><p>The methods are:</p>
<ul>
<li><code>bind</code></li>
<li><code>create_with</code></li>
<li><code>distinct</code></li>
<li><code>eager_load</code></li>
<li><code>extending</code></li>
<li><code>from</code></li>
<li><code>group</code></li>
<li><code>having</code></li>
<li><code>includes</code></li>
<li><code>joins</code></li>
<li><code>limit</code></li>
<li><code>lock</code></li>
<li><code>none</code></li>
<li><code>offset</code></li>
<li><code>order</code></li>
<li><code>preload</code></li>
<li><code>readonly</code></li>
<li><code>references</code></li>
<li><code>reorder</code></li>
<li><code>reverse_order</code></li>
<li><code>select</code></li>
<li><code>uniq</code></li>
<li><code>where</code></li>
</ul>
<p>All of the above methods return an instance of <code>ActiveRecord::Relation</code>.</p><p>The primary operation of <code>Model.find(options)</code> can be summarized as:</p>
<ul>
<li>Convert the supplied options to an equivalent SQL query.</li>
<li>Fire the SQL query and retrieve the corresponding results from the database.</li>
<li>Instantiate the equivalent Ruby object of the appropriate model for every resulting row.</li>
<li>Run <code>after_find</code> and then <code>after_initialize</code> callbacks, if any.</li>
</ul>
<h4 id="retrieving-a-single-object">1.1 Retrieving a Single Object</h4><p>Active Record provides several different ways of retrieving a single object.</p><h5 id="find">1.1.1 <code>find</code>
</h5><p>Using the <code>find</code> method, you can retrieve the object corresponding to the specified <em>primary key</em> that matches any supplied options. For example:</p><div class="code_container">
<div><div id="highlighter_872327" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby comments"># Find the client with primary key (id) 10.</code></div><div class="line number2 index1 alt1"><code class="ruby plain">client = Client.find(</code><code class="ruby constants">10</code><code class="ruby plain">)</code></div><div class="line number3 index2 alt2"><code class="ruby comments"># =&gt; #&lt;Client id: 10, first_name: "Ryan"&gt;</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_410438" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">(clients.id = 10) LIMIT 1</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>find</code> method will raise an <code>ActiveRecord::RecordNotFound</code> exception if no matching record is found.</p><p>You can also use this method to query for multiple objects. Call the <code>find</code>
 method and pass in an array of primary keys. The return will be an 
array containing all of the matching records for the supplied <em>primary keys</em>. For example:</p><div class="code_container">
<div><div id="highlighter_317314" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby comments"># Find the clients with primary keys 1 and 10.</code></div><div class="line number2 index1 alt1"><code class="ruby plain">client = Client.find([</code><code class="ruby constants">1</code><code class="ruby plain">, </code><code class="ruby constants">10</code><code class="ruby plain">]) </code><code class="ruby comments"># Or even Client.find(1, 10)</code></div><div class="line number3 index2 alt2"><code class="ruby comments"># =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;, #&lt;Client id: 10, first_name: "Ryan"&gt;]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_581116" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">(clients.id </code><code class="sql color1">IN</code> <code class="sql plain">(1,10))</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="warning"><p>The <code>find</code> method will raise an <code>ActiveRecord::RecordNotFound</code> exception unless a matching record is found for <strong>all</strong> of the supplied primary keys.</p></div><h5 id="take">1.1.2 <code>take</code>
</h5><p>The <code>take</code> method retrieves a record without any implicit ordering. For example:</p><div class="code_container">
<div><div id="highlighter_933525" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">client = Client.take</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_897672" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients LIMIT 1</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>take</code> method returns <code>nil</code> if no record is found and no exception will be raised.</p><p>You can pass in a numerical argument to the <code>take</code> method to return up to that number of results. For example</p><div class="code_container">
<div><div id="highlighter_696199" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">client = Client.take(</code><code class="ruby constants">2</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; [</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 1, first_name: "Lifo"&gt;,</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 220, first_name: "Sara"&gt;</code></div><div class="line number5 index4 alt2"><code class="ruby plain">]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_867448" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients LIMIT 2</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>take!</code> method behaves exactly like <code>take</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found.</p><div class="info"><p>The retrieved record may vary depending on the database engine.</p></div><h5 id="first">1.1.3 <code>first</code>
</h5><p>The <code>first</code> method finds the first record ordered by the primary key. For example:</p><div class="code_container">
<div><div id="highlighter_133923" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">client = Client.first</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_533350" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">clients.id </code><code class="sql keyword">ASC</code> <code class="sql plain">LIMIT 1</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>first</code> method returns <code>nil</code> if no matching record is found and no exception will be raised.</p><p>You can pass in a numerical argument to the <code>first</code> method to return up to that number of results. For example</p><div class="code_container">
<div><div id="highlighter_153917" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">client = Client.first(</code><code class="ruby constants">3</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; [</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 1, first_name: "Lifo"&gt;,</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 2, first_name: "Fifo"&gt;,</code></div><div class="line number5 index4 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 3, first_name: "Filo"&gt;</code></div><div class="line number6 index5 alt1"><code class="ruby plain">]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_324553" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">clients.id </code><code class="sql keyword">ASC</code> <code class="sql plain">LIMIT 3</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>first!</code> method behaves exactly like <code>first</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found.</p><h5 id="last">1.1.4 <code>last</code>
</h5><p>The <code>last</code> method finds the last record ordered by the primary key. For example:</p><div class="code_container">
<div><div id="highlighter_823250" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">client = Client.last</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; #&lt;Client id: 221, first_name: "Russel"&gt;</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_714851" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">clients.id </code><code class="sql keyword">DESC</code> <code class="sql plain">LIMIT 1</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>last</code> method returns <code>nil</code> if no matching record is found and no exception will be raised.</p><p>You can pass in a numerical argument to the <code>last</code> method to return up to that number of results. For example</p><div class="code_container">
<div><div id="highlighter_500784" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">client = Client.last(</code><code class="ruby constants">3</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; [</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 219, first_name: "James"&gt;,</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 220, first_name: "Sara"&gt;,</code></div><div class="line number5 index4 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 221, first_name: "Russel"&gt;</code></div><div class="line number6 index5 alt1"><code class="ruby plain">]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_263167" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">clients.id </code><code class="sql keyword">DESC</code> <code class="sql plain">LIMIT 3</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>last!</code> method behaves exactly like <code>last</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found.</p><h5 id="find-by">1.1.5 <code>find_by</code>
</h5><p>The <code>find_by</code> method finds the first record matching some conditions. For example:</p><div class="code_container">
<div><div id="highlighter_888604" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.find_by first_name: </code><code class="ruby string">'Lifo'</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="ruby plain">Client.find_by first_name: </code><code class="ruby string">'Jon'</code></div><div class="line number5 index4 alt2"><code class="ruby comments"># =&gt; nil</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>It is equivalent to writing:</p><div class="code_container">
<div><div id="highlighter_320167" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(first_name: </code><code class="ruby string">'Lifo'</code><code class="ruby plain">).take</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL equivalent of the above is:</p><div class="code_container">
<div><div id="highlighter_204523" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">(clients.first_name = </code><code class="sql string">'Lifo'</code><code class="sql plain">) LIMIT 1</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>find_by!</code> method behaves exactly like <code>find_by</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found. For example:</p><div class="code_container">
<div><div id="highlighter_99714" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.find_by! first_name: </code><code class="ruby string">'does not exist'</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; ActiveRecord::RecordNotFound</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This is equivalent to writing:</p><div class="code_container">
<div><div id="highlighter_156517" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(first_name: </code><code class="ruby string">'does not exist'</code><code class="ruby plain">).take!</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="retrieving-multiple-objects-in-batches">1.2 Retrieving Multiple Objects in Batches</h4><p>We
 often need to iterate over a large set of records, as when we send a 
newsletter to a large set of users, or when we export data.</p><p>This may appear straightforward:</p><div class="code_container">
<div><div id="highlighter_142148" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby comments"># This is very inefficient when the users table has thousands of rows.</code></div><div class="line number2 index1 alt1"><code class="ruby plain">User.all.</code><code class="ruby keyword">each</code> <code class="ruby keyword">do</code> <code class="ruby plain">|user|</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">NewsMailer.weekly(user).deliver_now</code></div><div class="line number4 index3 alt1"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>But this approach becomes increasingly impractical as the table size increases, since <code>User.all.each</code> instructs Active Record to fetch <em>the entire table</em>
 in a single pass, build a model object per row, and then keep the 
entire array of model objects in memory. Indeed, if we have a large 
number of records, the entire collection may exceed the amount of memory
 available.</p><p>Rails provides two methods that address this problem 
by dividing records into memory-friendly batches for processing. The 
first method, <code>find_each</code>, retrieves a batch of records and then yields <em>each</em> record to the block individually as a model. The second method, <code>find_in_batches</code>, retrieves a batch of records and then yields <em>the entire batch</em> to the block as an array of models.</p><div class="info"><p>The <code>find_each</code> and <code>find_in_batches</code>
 methods are intended for use in the batch processing of a large number 
of records that wouldn't fit in memory all at once. If you just need to 
loop over a thousand records the regular find methods are the preferred 
option.</p></div><h5 id="find-each">1.2.1 <code>find_each</code>
</h5><p>The <code>find_each</code> method retrieves a batch of records and then yields <em>each</em> record to the block individually as a model. In the following example, <code>find_each</code> will retrieve 1000 records (the current default for both <code>find_each</code> and <code>find_in_batches</code>)
 and then yield each record individually to the block as a model. This 
process is repeated until all of the records have been processed:</p><div class="code_container">
<div><div id="highlighter_66603" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.find_each </code><code class="ruby keyword">do</code> <code class="ruby plain">|user|</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">NewsMailer.weekly(user).deliver_now</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>To add conditions to a <code>find_each</code> operation you can chain other Active Record methods such as <code>where</code>:</p><div class="code_container">
<div><div id="highlighter_724058" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.where(weekly_subscriber: </code><code class="ruby keyword">true</code><code class="ruby plain">).find_each </code><code class="ruby keyword">do</code> <code class="ruby plain">|user|</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">NewsMailer.weekly(user).deliver_now</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<h6 id="options-for-find-each">1.2.1.1 Options for <code>find_each</code>
</h6><p>The <code>find_each</code> method accepts most of the options allowed by the regular <code>find</code> method, except for <code>:order</code> and <code>:limit</code>, which are reserved for internal use by <code>find_each</code>.</p><p>Three additional options, <code>:batch_size</code>, <code>:begin_at</code> and <code>:end_at</code>, are available as well.</p><p><strong><code>:batch_size</code></strong></p><p>The <code>:batch_size</code>
 option allows you to specify the number of records to be retrieved in 
each batch, before being passed individually to the block. For example, 
to retrieve records in batches of 5000:</p><div class="code_container">
<div><div id="highlighter_889497" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.find_each(batch_size: </code><code class="ruby constants">5000</code><code class="ruby plain">) </code><code class="ruby keyword">do</code> <code class="ruby plain">|user|</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">NewsMailer.weekly(user).deliver_now</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p><strong><code>:begin_at</code></strong></p><p>By default, records are fetched in ascending order of the primary key, which must be an integer. The <code>:begin_at</code>
 option allows you to configure the first ID of the sequence whenever 
the lowest ID is not the one you need. This would be useful, for 
example, if you wanted to resume an interrupted batch process, provided 
you saved the last processed ID as a checkpoint.</p><p>For example, to send newsletters only to users with the primary key starting from 2000, and to retrieve them in batches of 5000:</p><div class="code_container">
<div><div id="highlighter_110761" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.find_each(begin_at: </code><code class="ruby constants">2000</code><code class="ruby plain">, batch_size: </code><code class="ruby constants">5000</code><code class="ruby plain">) </code><code class="ruby keyword">do</code> <code class="ruby plain">|user|</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">NewsMailer.weekly(user).deliver_now</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Another example would be if you wanted multiple workers handling the 
same processing queue. You could have each worker handle 10000 records 
by setting the appropriate <code>:begin_at</code> option on each worker.</p><p><strong><code>:end_at</code></strong></p><p>Similar to the <code>:begin_at</code> option, <code>:end_at</code> allows you to configure the last ID of the sequence whenever the highest ID is not the one you need.
This would be useful, for example, if you wanted to run a batch process, using a subset of records based on <code>:begin_at</code> and <code>:end_at</code></p><p>For
 example, to send newsletters only to users with the primary key 
starting from 2000 up to 10000 and to retrieve them in batches of 5000:</p><div class="code_container">
<div><div id="highlighter_997645" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.find_each(begin_at: </code><code class="ruby constants">2000</code><code class="ruby plain">, end_at: </code><code class="ruby constants">10000</code><code class="ruby plain">, batch_size: </code><code class="ruby constants">5000</code><code class="ruby plain">) </code><code class="ruby keyword">do</code> <code class="ruby plain">|user|</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">NewsMailer.weekly(user).deliver_now</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<h5 id="find-in-batches">1.2.2 <code>find_in_batches</code>
</h5><p>The <code>find_in_batches</code> method is similar to <code>find_each</code>, since both retrieve batches of records. The difference is that <code>find_in_batches</code> yields <em>batches</em>
 to the block as an array of models, instead of individually. The 
following example will yield to the supplied block an array of up to 
1000 invoices at a time, with the final block containing any remaining 
invoices:</p><div class="code_container">
<div><div id="highlighter_895352" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby comments"># Give add_invoices an array of 1000 invoices at a time</code></div><div class="line number2 index1 alt1"><code class="ruby plain">Invoice.find_in_batches </code><code class="ruby keyword">do</code> <code class="ruby plain">|invoices|</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">export.add_invoices(invoices)</code></div><div class="line number4 index3 alt1"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<h6 id="options-for-find-in-batches">1.2.2.1 Options for <code>find_in_batches</code>
</h6><p>The <code>find_in_batches</code> method accepts the same <code>:batch_size</code>, <code>:begin_at</code> and <code>:end_at</code> options as <code>find_each</code>.</p><h3 id="conditions">2 Conditions</h3><p>The <code>where</code> method allows you to specify conditions to limit the records returned, representing the <code>WHERE</code>-part of the SQL statement. Conditions can either be specified as a string, array, or hash.</p><h4 id="pure-string-conditions">2.1 Pure String Conditions</h4><p>If you'd like to add conditions to your find, you could just specify them in there, just like <code>Client.where("orders_count = '2'")</code>. This will find all clients where the <code>orders_count</code> field's value is 2.</p><div class="warning"><p>Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. For example, <code>Client.where("first_name LIKE '%#{params[:first_name]}%'")</code> is not safe. See the next section for the preferred way to handle conditions using an array.</p></div><h4 id="array-conditions">2.2 Array Conditions</h4><p>Now what if that number could vary, say as an argument from somewhere? The find would then take the form:</p><div class="code_container">
<div><div id="highlighter_158936" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">"orders_count = ?"</code><code class="ruby plain">, params[</code><code class="ruby color2">:orders</code><code class="ruby plain">])</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Active Record will go through the first element in the conditions 
value and any additional elements will replace the question marks <code>(?)</code> in the first element.</p><p>If you want to specify multiple conditions:</p><div class="code_container">
<div><div id="highlighter_42555" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">"orders_count = ? AND locked = ?"</code><code class="ruby plain">, params[</code><code class="ruby color2">:orders</code><code class="ruby plain">], </code><code class="ruby keyword">false</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>In this example, the first question mark will be replaced with the value in <code>params[:orders]</code> and the second will be replaced with the SQL representation of <code>false</code>, which depends on the adapter.</p><p>This code is highly preferable:</p><div class="code_container">
<div><div id="highlighter_769979" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">"orders_count = ?"</code><code class="ruby plain">, params[</code><code class="ruby color2">:orders</code><code class="ruby plain">])</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>to this code:</p><div class="code_container">
<div><div id="highlighter_755247" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">"orders_count = #{params[:orders]}"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database <strong>as-is</strong>.
 This means that it will be an unescaped variable directly from a user 
who may have malicious intent. If you do this, you put your entire 
database at risk because once a user finds out they can exploit your 
database they can do just about anything to it. Never ever put your 
arguments directly inside the conditions string.</p><div class="info"><p>For more information on the dangers of SQL injection, see the <a href="http://edgeguides.rubyonrails.org/security.html#sql-injection">Ruby on Rails Security Guide</a>.</p></div><h5 id="placeholder-conditions">2.2.1 Placeholder Conditions</h5><p>Similar to the <code>(?)</code> replacement style of params, you can also specify keys/values hash in your array conditions:</p><div class="code_container">
<div><div id="highlighter_982737" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">"created_at &gt;= :start_date AND created_at &lt;= :end_date"</code><code class="ruby plain">,</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">{start_date: params[</code><code class="ruby color2">:start_date</code><code class="ruby plain">], end_date: params[</code><code class="ruby color2">:end_date</code><code class="ruby plain">]})</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This makes for clearer readability if you have a large number of variable conditions.</p><h4 id="hash-conditions">2.3 Hash Conditions</h4><p>Active
 Record also allows you to pass in hash conditions which can increase 
the readability of your conditions syntax. With hash conditions, you 
pass in a hash with keys of the fields you want conditionalised and the 
values of how you want to conditionalise them:</p><div class="note"><p>Only equality, range and subset checking are possible with Hash conditions.</p></div><h5 id="equality-conditions">2.3.1 Equality Conditions</h5><div class="code_container">
<div><div id="highlighter_333242" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(locked: </code><code class="ruby keyword">true</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The field name can also be a string:</p><div class="code_container">
<div><div id="highlighter_185018" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">'locked'</code> <code class="ruby plain">=&gt; </code><code class="ruby keyword">true</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>In the case of a belongs_to relationship, an association key can be 
used to specify the model if an Active Record object is used as the 
value. This method works with polymorphic relationships as well.</p><div class="code_container">
<div><div id="highlighter_802604" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.where(author: author)</code></div><div class="line number2 index1 alt1"><code class="ruby plain">Author.joins(</code><code class="ruby color2">:articles</code><code class="ruby plain">).where(articles: { author: author })</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="note"><p>The values cannot be symbols. For example, you cannot do <code>Client.where(status: :active)</code>.</p></div><h5 id="range-conditions">2.3.2 Range Conditions</h5><div class="code_container">
<div><div id="highlighter_378664" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(created_at: (</code><code class="ruby color1">Time</code><code class="ruby plain">.now.midnight - </code><code class="ruby constants">1</code><code class="ruby plain">.day)..</code><code class="ruby color1">Time</code><code class="ruby plain">.now.midnight)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This will find all clients created yesterday by using a <code>BETWEEN</code> SQL statement:</p><div class="code_container">
<div><div id="highlighter_92330" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">(clients.created_at </code><code class="sql color1">BETWEEN</code> <code class="sql string">'2008-12-21 00:00:00'</code> <code class="sql color1">AND</code> <code class="sql string">'2008-12-22 00:00:00'</code><code class="sql plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This demonstrates a shorter syntax for the examples in <a href="#array-conditions">Array Conditions</a></p><h5 id="subset-conditions">2.3.3 Subset Conditions</h5><p>If you want to find records using the <code>IN</code> expression you can pass an array to the conditions hash:</p><div class="code_container">
<div><div id="highlighter_308904" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(orders_count: [</code><code class="ruby constants">1</code><code class="ruby plain">,</code><code class="ruby constants">3</code><code class="ruby plain">,</code><code class="ruby constants">5</code><code class="ruby plain">])</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This code will generate SQL like this:</p><div class="code_container">
<div><div id="highlighter_835001" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">(clients.orders_count </code><code class="sql color1">IN</code> <code class="sql plain">(1,3,5))</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="not-conditions">2.4 NOT Conditions</h4><p><code>NOT</code> SQL queries can be built by <code>where.not</code>.</p><div class="code_container">
<div><div id="highlighter_903418" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.where.</code><code class="ruby keyword">not</code><code class="ruby plain">(author: author)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>In other words, this query can be generated by calling <code>where</code> with no argument, then immediately chain with <code>not</code> passing <code>where</code> conditions.</p><h3 id="ordering">3 Ordering</h3><p>To retrieve records from the database in a specific order, you can use the <code>order</code> method.</p><p>For example, if you're getting a set of records and want to order them in ascending order by the <code>created_at</code> field in your table:</p><div class="code_container">
<div><div id="highlighter_707997" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.order(</code><code class="ruby color2">:created_at</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># OR</code></div><div class="line number3 index2 alt2"><code class="ruby plain">Client.order(</code><code class="ruby string">"created_at"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>You could specify <code>ASC</code> or <code>DESC</code> as well:</p><div class="code_container">
<div><div id="highlighter_301979" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.order(created_at: </code><code class="ruby color2">:desc</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># OR</code></div><div class="line number3 index2 alt2"><code class="ruby plain">Client.order(created_at: </code><code class="ruby color2">:asc</code><code class="ruby plain">)</code></div><div class="line number4 index3 alt1"><code class="ruby comments"># OR</code></div><div class="line number5 index4 alt2"><code class="ruby plain">Client.order(</code><code class="ruby string">"created_at DESC"</code><code class="ruby plain">)</code></div><div class="line number6 index5 alt1"><code class="ruby comments"># OR</code></div><div class="line number7 index6 alt2"><code class="ruby plain">Client.order(</code><code class="ruby string">"created_at ASC"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Or ordering by multiple fields:</p><div class="code_container">
<div><div id="highlighter_429677" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.order(orders_count: </code><code class="ruby color2">:asc</code><code class="ruby plain">, created_at: </code><code class="ruby color2">:desc</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># OR</code></div><div class="line number3 index2 alt2"><code class="ruby plain">Client.order(</code><code class="ruby color2">:orders_count</code><code class="ruby plain">, created_at: </code><code class="ruby color2">:desc</code><code class="ruby plain">)</code></div><div class="line number4 index3 alt1"><code class="ruby comments"># OR</code></div><div class="line number5 index4 alt2"><code class="ruby plain">Client.order(</code><code class="ruby string">"orders_count ASC, created_at DESC"</code><code class="ruby plain">)</code></div><div class="line number6 index5 alt1"><code class="ruby comments"># OR</code></div><div class="line number7 index6 alt2"><code class="ruby plain">Client.order(</code><code class="ruby string">"orders_count ASC"</code><code class="ruby plain">, </code><code class="ruby string">"created_at DESC"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>If you want to call <code>order</code> multiple times e.g. in different context, new order will append previous one:</p><div class="code_container">
<div><div id="highlighter_822597" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.order(</code><code class="ruby string">"orders_count ASC"</code><code class="ruby plain">).order(</code><code class="ruby string">"created_at DESC"</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="selecting-specific-fields">4 Selecting Specific Fields</h3><p>By default, <code>Model.find</code> selects all the fields from the result set using <code>select *</code>.</p><p>To select only a subset of fields from the result set, you can specify the subset via the <code>select</code> method.</p><p>For example, to select only <code>viewable_by</code> and <code>locked</code> columns:</p><div class="code_container">
<div><div id="highlighter_725908" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.select(</code><code class="ruby string">"viewable_by, locked"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL query used by this find call will be somewhat like:</p><div class="code_container">
<div><div id="highlighter_895948" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">viewable_by, locked </code><code class="sql keyword">FROM</code> <code class="sql plain">clients</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Be careful because this also means you're initializing a model object
 with only the fields that you've selected. If you attempt to access a 
field that is not in the initialized record you'll receive:</p><div class="code_container">
<div><div id="highlighter_510231" class="syntaxhighlighter nogutter  plain"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain plain">ActiveModel::MissingAttributeError: missing attribute: &lt;attribute&gt;</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Where <code>&lt;attribute&gt;</code> is the attribute you asked for. The <code>id</code> method will not raise the <code>ActiveRecord::MissingAttributeError</code>, so just be careful when working with associations because they need the <code>id</code> method to function properly.</p><p>If you would like to only grab a single record per unique value in a certain field, you can use <code>distinct</code>:</p><div class="code_container">
<div><div id="highlighter_788156" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.select(</code><code class="ruby color2">:name</code><code class="ruby plain">).distinct</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This would generate SQL like:</p><div class="code_container">
<div><div id="highlighter_227420" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql keyword">DISTINCT</code> <code class="sql keyword">name</code> <code class="sql keyword">FROM</code> <code class="sql plain">clients</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>You can also remove the uniqueness constraint:</p><div class="code_container">
<div><div id="highlighter_757156" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">query = Client.select(</code><code class="ruby color2">:name</code><code class="ruby plain">).distinct</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; Returns unique names</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="ruby plain">query.distinct(</code><code class="ruby keyword">false</code><code class="ruby plain">)</code></div><div class="line number5 index4 alt2"><code class="ruby comments"># =&gt; Returns all names, even if there are duplicates</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="limit-and-offset">5 Limit and Offset</h3><p>To apply <code>LIMIT</code> to the SQL fired by the <code>Model.find</code>, you can specify the <code>LIMIT</code> using <code>limit</code> and <code>offset</code> methods on the relation.</p><p>You can use <code>limit</code> to specify the number of records to be retrieved, and use <code>offset</code> to specify the number of records to skip before starting to return the records. For example</p><div class="code_container">
<div><div id="highlighter_425235" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.limit(</code><code class="ruby constants">5</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>will return a maximum of 5 clients and because it specifies no offset
 it will return the first 5 in the table. The SQL it executes looks like
 this:</p><div class="code_container">
<div><div id="highlighter_787691" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients LIMIT 5</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Adding <code>offset</code> to that</p><div class="code_container">
<div><div id="highlighter_600653" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.limit(</code><code class="ruby constants">5</code><code class="ruby plain">).offset(</code><code class="ruby constants">30</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>will return instead a maximum of 5 clients beginning with the 31st. The SQL looks like:</p><div class="code_container">
<div><div id="highlighter_815242" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients LIMIT 5 OFFSET 30</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="group">6 Group</h3><p>To apply a <code>GROUP BY</code> clause to the SQL fired by the finder, you can specify the <code>group</code> method on the find.</p><p>For example, if you want to find a collection of the dates orders were created on:</p><div class="code_container">
<div><div id="highlighter_751085" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Order.select(</code><code class="ruby string">"date(created_at) as ordered_date, sum(price) as total_price"</code><code class="ruby plain">).group(</code><code class="ruby string">"date(created_at)"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>And this will give you a single <code>Order</code> object for each date where there are orders in the database.</p><p>The SQL that would be executed would be something like this:</p><div class="code_container">
<div><div id="highlighter_173794" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql keyword">date</code><code class="sql plain">(created_at) </code><code class="sql keyword">as</code> <code class="sql plain">ordered_date, </code><code class="sql color2">sum</code><code class="sql plain">(price) </code><code class="sql keyword">as</code> <code class="sql plain">total_price</code></div><div class="line number2 index1 alt1"><code class="sql keyword">FROM</code> <code class="sql plain">orders</code></div><div class="line number3 index2 alt2"><code class="sql keyword">GROUP</code> <code class="sql keyword">BY</code> <code class="sql keyword">date</code><code class="sql plain">(created_at)</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="total-of-grouped-items">6.1 Total of grouped items</h4><p>To get the total of grouped items on a single query call <code>count</code> after the <code>group</code>.</p><div class="code_container">
<div><div id="highlighter_712127" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Order.group(</code><code class="ruby color2">:status</code><code class="ruby plain">).count</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; { 'awaiting_approval' =&gt; 7, 'paid' =&gt; 12 }</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed would be something like this:</p><div class="code_container">
<div><div id="highlighter_133496" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql color2">COUNT</code> <code class="sql plain">(*) </code><code class="sql keyword">AS</code> <code class="sql plain">count_all, status </code><code class="sql keyword">AS</code> <code class="sql plain">status</code></div><div class="line number2 index1 alt1"><code class="sql keyword">FROM</code> <code class="sql string">"orders"</code></div><div class="line number3 index2 alt2"><code class="sql keyword">GROUP</code> <code class="sql keyword">BY</code> <code class="sql plain">status</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="having">7 Having</h3><p>SQL uses the <code>HAVING</code> clause to specify conditions on the <code>GROUP BY</code> fields. You can add the <code>HAVING</code> clause to the SQL fired by the <code>Model.find</code> by adding the <code>having</code> method to the find.</p><p>For example:</p><div class="code_container">
<div><div id="highlighter_723776" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Order.select(</code><code class="ruby string">"date(created_at) as ordered_date, sum(price) as total_price"</code><code class="ruby plain">).</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">group(</code><code class="ruby string">"date(created_at)"</code><code class="ruby plain">).having(</code><code class="ruby string">"sum(price) &gt; ?"</code><code class="ruby plain">, </code><code class="ruby constants">100</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed would be something like this:</p><div class="code_container">
<div><div id="highlighter_781938" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql keyword">date</code><code class="sql plain">(created_at) </code><code class="sql keyword">as</code> <code class="sql plain">ordered_date, </code><code class="sql color2">sum</code><code class="sql plain">(price) </code><code class="sql keyword">as</code> <code class="sql plain">total_price</code></div><div class="line number2 index1 alt1"><code class="sql keyword">FROM</code> <code class="sql plain">orders</code></div><div class="line number3 index2 alt2"><code class="sql keyword">GROUP</code> <code class="sql keyword">BY</code> <code class="sql keyword">date</code><code class="sql plain">(created_at)</code></div><div class="line number4 index3 alt1"><code class="sql keyword">HAVING</code> <code class="sql color2">sum</code><code class="sql plain">(price) &gt; 100</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This will return single order objects for each day, but only those that are ordered more than $100 in a day.</p><h3 id="overriding-conditions">8 Overriding Conditions</h3><h4 id="unscope">8.1 <code>unscope</code>
</h4><p>You can specify certain conditions to be removed using the <code>unscope</code> method. For example:</p><div class="code_container">
<div><div id="highlighter_7223" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.where(</code><code class="ruby string">'id &gt; 10'</code><code class="ruby plain">).limit(</code><code class="ruby constants">20</code><code class="ruby plain">).order(</code><code class="ruby string">'id asc'</code><code class="ruby plain">).unscope(</code><code class="ruby color2">:order</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed:</p><div class="code_container">
<div><div id="highlighter_50559" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles </code><code class="sql keyword">WHERE</code> <code class="sql plain">id &gt; 10 LIMIT 20</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="sql plain"># Original query without `unscope`</code></div><div class="line number4 index3 alt1"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles </code><code class="sql keyword">WHERE</code> <code class="sql plain">id &gt; 10 </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">id </code><code class="sql keyword">asc</code> <code class="sql plain">LIMIT 20</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>You can also unscope specific <code>where</code> clauses. For example:</p><div class="code_container">
<div><div id="highlighter_802925" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.where(id: </code><code class="ruby constants">10</code><code class="ruby plain">, trashed: </code><code class="ruby keyword">false</code><code class="ruby plain">).unscope(where: </code><code class="ruby color2">:id</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT "articles".* FROM "articles" WHERE trashed = 0</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>A relation which has used <code>unscope</code> will affect any relation it is
merged in to:</p><div class="code_container">
<div><div id="highlighter_501789" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.order(</code><code class="ruby string">'id asc'</code><code class="ruby plain">).merge(Article.unscope(</code><code class="ruby color2">:order</code><code class="ruby plain">))</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT "articles".* FROM "articles"</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="only">8.2 <code>only</code>
</h4><p>You can also override conditions using the <code>only</code> method. For example:</p><div class="code_container">
<div><div id="highlighter_994421" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.where(</code><code class="ruby string">'id &gt; 10'</code><code class="ruby plain">).limit(</code><code class="ruby constants">20</code><code class="ruby plain">).order(</code><code class="ruby string">'id desc'</code><code class="ruby plain">).only(</code><code class="ruby color2">:order</code><code class="ruby plain">, </code><code class="ruby color2">:where</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed:</p><div class="code_container">
<div><div id="highlighter_132674" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles </code><code class="sql keyword">WHERE</code> <code class="sql plain">id &gt; 10 </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">id </code><code class="sql keyword">DESC</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="sql plain"># Original query without `</code><code class="sql keyword">only</code><code class="sql plain">`</code></div><div class="line number4 index3 alt1"><code class="sql keyword">SELECT</code> <code class="sql string">"articles"</code><code class="sql plain">.* </code><code class="sql keyword">FROM</code> <code class="sql string">"articles"</code> <code class="sql keyword">WHERE</code> <code class="sql plain">(id &gt; 10) </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">id </code><code class="sql keyword">desc</code> <code class="sql plain">LIMIT 20</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="reorder">8.3 <code>reorder</code>
</h4><p>The <code>reorder</code> method overrides the default scope order. For example:</p><div class="code_container">
<div><div id="highlighter_376268" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Article &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_many </code><code class="ruby color2">:comments</code><code class="ruby plain">, -&gt; { order(</code><code class="ruby string">'posted_at DESC'</code><code class="ruby plain">) }</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="ruby plain">Article.find(</code><code class="ruby constants">10</code><code class="ruby plain">).comments.reorder(</code><code class="ruby string">'name'</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed:</p><div class="code_container">
<div><div id="highlighter_179539" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles </code><code class="sql keyword">WHERE</code> <code class="sql plain">id = 10</code></div><div class="line number2 index1 alt1"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">comments </code><code class="sql keyword">WHERE</code> <code class="sql plain">article_id = 10 </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql keyword">name</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>In case the <code>reorder</code> clause is not used, the SQL executed would be:</p><div class="code_container">
<div><div id="highlighter_901339" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles </code><code class="sql keyword">WHERE</code> <code class="sql plain">id = 10</code></div><div class="line number2 index1 alt1"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">comments </code><code class="sql keyword">WHERE</code> <code class="sql plain">article_id = 10 </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">posted_at </code><code class="sql keyword">DESC</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="reverse-order">8.4 <code>reverse_order</code>
</h4><p>The <code>reverse_order</code> method reverses the ordering clause if specified.</p><div class="code_container">
<div><div id="highlighter_941546" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">"orders_count &gt; 10"</code><code class="ruby plain">).order(</code><code class="ruby color2">:name</code><code class="ruby plain">).reverse_order</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed:</p><div class="code_container">
<div><div id="highlighter_23947" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">orders_count &gt; 10 </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql keyword">name</code> <code class="sql keyword">DESC</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>If no ordering clause is specified in the query, the <code>reverse_order</code> orders by the primary key in reverse order.</p><div class="code_container">
<div><div id="highlighter_397800" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(</code><code class="ruby string">"orders_count &gt; 10"</code><code class="ruby plain">).reverse_order</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed:</p><div class="code_container">
<div><div id="highlighter_29803" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">orders_count &gt; 10 </code><code class="sql keyword">ORDER</code> <code class="sql keyword">BY</code> <code class="sql plain">clients.id </code><code class="sql keyword">DESC</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This method accepts <strong>no</strong> arguments.</p><h4 id="rewhere">8.5 <code>rewhere</code>
</h4><p>The <code>rewhere</code> method overrides an existing, named where condition. For example:</p><div class="code_container">
<div><div id="highlighter_744890" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.where(trashed: </code><code class="ruby keyword">true</code><code class="ruby plain">).rewhere(trashed: </code><code class="ruby keyword">false</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL that would be executed:</p><div class="code_container">
<div><div id="highlighter_79339" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles </code><code class="sql keyword">WHERE</code> <code class="sql plain">`trashed` = 0</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>In case the <code>rewhere</code> clause is not used,</p><div class="code_container">
<div><div id="highlighter_504797" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.where(trashed: </code><code class="ruby keyword">true</code><code class="ruby plain">).where(trashed: </code><code class="ruby keyword">false</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>the SQL executed would be:</p><div class="code_container">
<div><div id="highlighter_482726" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles </code><code class="sql keyword">WHERE</code> <code class="sql plain">`trashed` = 1 </code><code class="sql color1">AND</code> <code class="sql plain">`trashed` = 0</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="null-relation">9 Null Relation</h3><p>The <code>none</code> 
method returns a chainable relation with no records. Any subsequent 
conditions chained to the returned relation will continue generating 
empty relations. This is useful in scenarios where you need a chainable 
response to a method or a scope that could return zero results.</p><div class="code_container">
<div><div id="highlighter_75112" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.none </code><code class="ruby comments"># returns an empty Relation and fires no queries.</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="code_container">
<div><div id="highlighter_446756" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby comments"># The visible_articles method below is expected to return a Relation.</code></div><div class="line number2 index1 alt1"><code class="ruby variable bold">@articles</code> <code class="ruby plain">= current_user.visible_articles.where(name: params[</code><code class="ruby color2">:name</code><code class="ruby plain">])</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="ruby keyword">def</code> <code class="ruby plain">visible_articles</code></div><div class="line number5 index4 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">case</code> <code class="ruby plain">role</code></div><div class="line number6 index5 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">when</code> <code class="ruby string">'Country Manager'</code></div><div class="line number7 index6 alt2"><code class="ruby spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="ruby plain">Article.where(country: country)</code></div><div class="line number8 index7 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">when</code> <code class="ruby string">'Reviewer'</code></div><div class="line number9 index8 alt2"><code class="ruby spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="ruby plain">Article.published</code></div><div class="line number10 index9 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">when</code> <code class="ruby string">'Bad User'</code></div><div class="line number11 index10 alt2"><code class="ruby spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="ruby plain">Article.none </code><code class="ruby comments"># =&gt; returning [] or nil breaks the caller code in this case</code></div><div class="line number12 index11 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">end</code></div><div class="line number13 index12 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="readonly-objects">10 Readonly Objects</h3><p>Active Record provides <code>readonly</code>
 method on a relation to explicitly disallow modification of any of the 
returned objects. Any attempt to alter a readonly record will not 
succeed, raising an <code>ActiveRecord::ReadOnlyRecord</code> exception.</p><div class="code_container">
<div><div id="highlighter_246025" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">client = Client.readonly.first</code></div><div class="line number2 index1 alt1"><code class="ruby plain">client.visits += </code><code class="ruby constants">1</code></div><div class="line number3 index2 alt2"><code class="ruby plain">client.save</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>As <code>client</code> is explicitly set to be a readonly object, the above code will raise an <code>ActiveRecord::ReadOnlyRecord</code> exception when calling <code>client.save</code> with an updated value of <em>visits</em>.</p><h3 id="locking-records-for-update">11 Locking Records for Update</h3><p>Locking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.</p><p>Active Record provides two locking mechanisms:</p>
<ul>
<li>Optimistic Locking</li>
<li>Pessimistic Locking</li>
</ul>
<h4 id="optimistic-locking">11.1 Optimistic Locking</h4><p>Optimistic 
locking allows multiple users to access the same record for edits, and 
assumes a minimum of conflicts with the data. It does this by checking 
whether another process has made changes to a record since it was 
opened. An <code>ActiveRecord::StaleObjectError</code> exception is thrown if that has occurred and the update is ignored.</p><p><strong>Optimistic locking column</strong></p><p>In order to use optimistic locking, the table needs to have a column called <code>lock_version</code> of type integer. Each time the record is updated, Active Record increments the <code>lock_version</code> column. If an update request is made with a lower value in the <code>lock_version</code> field than is currently in the <code>lock_version</code> column in the database, the update request will fail with an <code>ActiveRecord::StaleObjectError</code>. Example:</p><div class="code_container">
<div><div id="highlighter_487299" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">c1 = Client.find(</code><code class="ruby constants">1</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby plain">c2 = Client.find(</code><code class="ruby constants">1</code><code class="ruby plain">)</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="ruby plain">c1.first_name = </code><code class="ruby string">"Michael"</code></div><div class="line number5 index4 alt2"><code class="ruby plain">c1.save</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="ruby plain">c2.name = </code><code class="ruby string">"should fail"</code></div><div class="line number8 index7 alt1"><code class="ruby plain">c2.save </code><code class="ruby comments"># Raises an ActiveRecord::StaleObjectError</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>You're then responsible for dealing with the conflict by rescuing the
 exception and either rolling back, merging, or otherwise apply the 
business logic needed to resolve the conflict.</p><p>This behavior can be turned off by setting <code>ActiveRecord::Base.lock_optimistically = false</code>.</p><p>To override the name of the <code>lock_version</code> column, <code>ActiveRecord::Base</code> provides a class attribute called <code>locking_column</code>:</p><div class="code_container">
<div><div id="highlighter_476111" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Client &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">self</code><code class="ruby plain">.locking_column = </code><code class="ruby color2">:lock_client_column</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="pessimistic-locking">11.2 Pessimistic Locking</h4><p>Pessimistic locking uses a locking mechanism provided by the underlying database. Using <code>lock</code> when building a relation obtains an exclusive lock on the selected rows. Relations using <code>lock</code> are usually wrapped inside a transaction for preventing deadlock conditions.</p><p>For example:</p><div class="code_container">
<div><div id="highlighter_766291" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Item.transaction </code><code class="ruby keyword">do</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">i = Item.lock.first</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">i.name = </code><code class="ruby string">'Jones'</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">i.save!</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The above session produces the following SQL for a MySQL backend:</p><div class="code_container">
<div><div id="highlighter_489269" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql plain">SQL (0.2ms)&nbsp;&nbsp; </code><code class="sql keyword">BEGIN</code></div><div class="line number2 index1 alt1"><code class="sql plain">Item </code><code class="sql keyword">Load</code> <code class="sql plain">(0.3ms)&nbsp;&nbsp; </code><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">`items` LIMIT 1 </code><code class="sql keyword">FOR</code> <code class="sql keyword">UPDATE</code></div><div class="line number3 index2 alt2"><code class="sql plain">Item </code><code class="sql keyword">Update</code> <code class="sql plain">(0.4ms)&nbsp;&nbsp; </code><code class="sql keyword">UPDATE</code> <code class="sql plain">`items` </code><code class="sql keyword">SET</code> <code class="sql plain">`updated_at` = </code><code class="sql string">'2009-02-07 18:05:56'</code><code class="sql plain">, `</code><code class="sql keyword">name</code><code class="sql plain">` = </code><code class="sql string">'Jones'</code> <code class="sql keyword">WHERE</code> <code class="sql plain">`id` = 1</code></div><div class="line number4 index3 alt1"><code class="sql plain">SQL (0.8ms)&nbsp;&nbsp; </code><code class="sql keyword">COMMIT</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>You can also pass raw SQL to the <code>lock</code> method for allowing different types of locks. For example, MySQL has an expression called <code>LOCK IN SHARE MODE</code>
 where you can lock a record but still allow other queries to read it. 
To specify this expression just pass it in as the lock option:</p><div class="code_container">
<div><div id="highlighter_497026" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Item.transaction </code><code class="ruby keyword">do</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">i = Item.lock(</code><code class="ruby string">"LOCK IN SHARE MODE"</code><code class="ruby plain">).find(</code><code class="ruby constants">1</code><code class="ruby plain">)</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">i.increment!(</code><code class="ruby color2">:views</code><code class="ruby plain">)</code></div><div class="line number4 index3 alt1"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>If you already have an instance of your model, you can start a 
transaction and acquire the lock in one go using the following code:</p><div class="code_container">
<div><div id="highlighter_869020" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">item = Item.first</code></div><div class="line number2 index1 alt1"><code class="ruby plain">item.with_lock </code><code class="ruby keyword">do</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments"># This block is called within a transaction,</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments"># item is already locked.</code></div><div class="line number5 index4 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">item.increment!(</code><code class="ruby color2">:views</code><code class="ruby plain">)</code></div><div class="line number6 index5 alt1"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="joining-tables">12 Joining Tables</h3><p>Active Record provides a finder method called <code>joins</code> for specifying <code>JOIN</code> clauses on the resulting SQL. There are multiple ways to use the <code>joins</code> method.</p><h4 id="using-a-string-sql-fragment">12.1 Using a String SQL Fragment</h4><p>You can just supply the raw SQL specifying the <code>JOIN</code> clause to <code>joins</code>:</p><div class="code_container">
<div><div id="highlighter_52146" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.joins(</code><code class="ruby string">'LEFT OUTER JOIN addresses ON addresses.client_id = clients.id'</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This will result in the following SQL:</p><div class="code_container">
<div><div id="highlighter_827791" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">clients.* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql color2">LEFT</code> <code class="sql color1">OUTER</code> <code class="sql color1">JOIN</code> <code class="sql plain">addresses </code><code class="sql keyword">ON</code> <code class="sql plain">addresses.client_id = clients.id</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="using-array-hash-of-named-associations">12.2 Using Array/Hash of Named Associations</h4><div class="warning"><p>This method only works with <code>INNER JOIN</code>.</p></div><p>Active Record lets you use the names of the <a href="http://edgeguides.rubyonrails.org/association_basics.html">associations</a> defined on the model as a shortcut for specifying <code>JOIN</code> clauses for those associations when using the <code>joins</code> method.</p><p>For example, consider the following <code>Category</code>, <code>Article</code>, <code>Comment</code>, <code>Guest</code> and <code>Tag</code> models:</p><div class="code_container">
<div><div id="highlighter_619393" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Category &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_many </code><code class="ruby color2">:articles</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Article &lt; ActiveRecord::Base</code></div><div class="line number6 index5 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">belongs_to </code><code class="ruby color2">:category</code></div><div class="line number7 index6 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_many </code><code class="ruby color2">:comments</code></div><div class="line number8 index7 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_many </code><code class="ruby color2">:tags</code></div><div class="line number9 index8 alt2"><code class="ruby keyword">end</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Comment &lt; ActiveRecord::Base</code></div><div class="line number12 index11 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">belongs_to </code><code class="ruby color2">:article</code></div><div class="line number13 index12 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">has_one </code><code class="ruby color2">:guest</code></div><div class="line number14 index13 alt1"><code class="ruby keyword">end</code></div><div class="line number15 index14 alt2">&nbsp;</div><div class="line number16 index15 alt1"><code class="ruby keyword">class</code> <code class="ruby plain">Guest &lt; ActiveRecord::Base</code></div><div class="line number17 index16 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">belongs_to </code><code class="ruby color2">:comment</code></div><div class="line number18 index17 alt1"><code class="ruby keyword">end</code></div><div class="line number19 index18 alt2">&nbsp;</div><div class="line number20 index19 alt1"><code class="ruby keyword">class</code> <code class="ruby plain">Tag &lt; ActiveRecord::Base</code></div><div class="line number21 index20 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">belongs_to </code><code class="ruby color2">:article</code></div><div class="line number22 index21 alt1"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Now all of the following will produce the expected join queries using <code>INNER JOIN</code>:</p><h5 id="joining-a-single-association">12.2.1 Joining a Single Association</h5><div class="code_container">
<div><div id="highlighter_714774" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Category.joins(</code><code class="ruby color2">:articles</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This produces:</p><div class="code_container">
<div><div id="highlighter_873229" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">categories.* </code><code class="sql keyword">FROM</code> <code class="sql plain">categories</code></div><div class="line number2 index1 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">articles </code><code class="sql keyword">ON</code> <code class="sql plain">articles.category_id = categories.id</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Or, in English: "return a Category object for all categories with 
articles". Note that you will see duplicate categories if more than one 
article has the same category. If you want unique categories, you can 
use <code>Category.joins(:articles).uniq</code>.</p><h5 id="joining-multiple-associations">12.2.2 Joining Multiple Associations</h5><div class="code_container">
<div><div id="highlighter_296699" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.joins(</code><code class="ruby color2">:category</code><code class="ruby plain">, </code><code class="ruby color2">:comments</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This produces:</p><div class="code_container">
<div><div id="highlighter_686444" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">articles.* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles</code></div><div class="line number2 index1 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">categories </code><code class="sql keyword">ON</code> <code class="sql plain">articles.category_id = categories.id</code></div><div class="line number3 index2 alt2"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">comments </code><code class="sql keyword">ON</code> <code class="sql plain">comments.article_id = articles.id</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Or, in English: "return all articles that have a category and at 
least one comment". Note again that articles with multiple comments will
 show up multiple times.</p><h5 id="joining-nested-associations-single-level">12.2.3 Joining Nested Associations (Single Level)</h5><div class="code_container">
<div><div id="highlighter_554713" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.joins(comments: </code><code class="ruby color2">:guest</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This produces:</p><div class="code_container">
<div><div id="highlighter_993388" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">articles.* </code><code class="sql keyword">FROM</code> <code class="sql plain">articles</code></div><div class="line number2 index1 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">comments </code><code class="sql keyword">ON</code> <code class="sql plain">comments.article_id = articles.id</code></div><div class="line number3 index2 alt2"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">guests </code><code class="sql keyword">ON</code> <code class="sql plain">guests.comment_id = comments.id</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Or, in English: "return all articles that have a comment made by a guest."</p><h5 id="joining-nested-associations-multiple-level">12.2.4 Joining Nested Associations (Multiple Level)</h5><div class="code_container">
<div><div id="highlighter_43967" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Category.joins(articles: [{ comments: </code><code class="ruby color2">:guest</code> <code class="ruby plain">}, </code><code class="ruby color2">:tags</code><code class="ruby plain">])</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This produces:</p><div class="code_container">
<div><div id="highlighter_462340" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">categories.* </code><code class="sql keyword">FROM</code> <code class="sql plain">categories</code></div><div class="line number2 index1 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">articles </code><code class="sql keyword">ON</code> <code class="sql plain">articles.category_id = categories.id</code></div><div class="line number3 index2 alt2"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">comments </code><code class="sql keyword">ON</code> <code class="sql plain">comments.article_id = articles.id</code></div><div class="line number4 index3 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">guests </code><code class="sql keyword">ON</code> <code class="sql plain">guests.comment_id = comments.id</code></div><div class="line number5 index4 alt2"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">tags </code><code class="sql keyword">ON</code> <code class="sql plain">tags.article_id = articles.id</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="specifying-conditions-on-the-joined-tables">12.3 Specifying Conditions on the Joined Tables</h4><p>You can specify conditions on the joined tables using the regular <a href="#array-conditions">Array</a> and <a href="#pure-string-conditions">String</a> conditions. <a href="#hash-conditions">Hash conditions</a> provides a special syntax for specifying conditions for the joined tables:</p><div class="code_container">
<div><div id="highlighter_569990" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">time_range = (</code><code class="ruby color1">Time</code><code class="ruby plain">.now.midnight - </code><code class="ruby constants">1</code><code class="ruby plain">.day)..</code><code class="ruby color1">Time</code><code class="ruby plain">.now.midnight</code></div><div class="line number2 index1 alt1"><code class="ruby plain">Client.joins(</code><code class="ruby color2">:orders</code><code class="ruby plain">).where(</code><code class="ruby string">'orders.created_at'</code> <code class="ruby plain">=&gt; time_range)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>An alternative and cleaner syntax is to nest the hash conditions:</p><div class="code_container">
<div><div id="highlighter_143572" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">time_range = (</code><code class="ruby color1">Time</code><code class="ruby plain">.now.midnight - </code><code class="ruby constants">1</code><code class="ruby plain">.day)..</code><code class="ruby color1">Time</code><code class="ruby plain">.now.midnight</code></div><div class="line number2 index1 alt1"><code class="ruby plain">Client.joins(</code><code class="ruby color2">:orders</code><code class="ruby plain">).where(orders: { created_at: time_range })</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This will find all clients who have orders that were created yesterday, again using a <code>BETWEEN</code> SQL expression.</p><h3 id="eager-loading-associations">13 Eager Loading Associations</h3><p>Eager loading is the mechanism for loading the associated records of the objects returned by <code>Model.find</code> using as few queries as possible.</p><p><strong>N + 1 queries problem</strong></p><p>Consider the following code, which finds 10 clients and prints their postcodes:</p><div class="code_container">
<div><div id="highlighter_560267" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">clients = Client.limit(</code><code class="ruby constants">10</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="ruby plain">clients.</code><code class="ruby keyword">each</code> <code class="ruby keyword">do</code> <code class="ruby plain">|client|</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">puts client.address.postcode</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This code looks fine at the first sight. But the problem lies within 
the total number of queries executed. The above code executes 1 (to find
 10 clients) + 10 (one per each client to load the address) = <strong>11</strong> queries in total.</p><p><strong>Solution to N + 1 queries problem</strong></p><p>Active Record lets you specify in advance all the associations that are going to be loaded. This is possible by specifying the <code>includes</code> method of the <code>Model.find</code> call. With <code>includes</code>, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.</p><p>Revisiting the above case, we could rewrite <code>Client.limit(10)</code> to use eager load addresses:</p><div class="code_container">
<div><div id="highlighter_64925" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">clients = Client.includes(</code><code class="ruby color2">:address</code><code class="ruby plain">).limit(</code><code class="ruby constants">10</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="ruby plain">clients.</code><code class="ruby keyword">each</code> <code class="ruby keyword">do</code> <code class="ruby plain">|client|</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">puts client.address.postcode</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The above code will execute just <strong>2</strong> queries, as opposed to <strong>11</strong> queries in the previous case:</p><div class="code_container">
<div><div id="highlighter_516397" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients LIMIT 10</code></div><div class="line number2 index1 alt1"><code class="sql keyword">SELECT</code> <code class="sql plain">addresses.* </code><code class="sql keyword">FROM</code> <code class="sql plain">addresses</code></div><div class="line number3 index2 alt2"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">WHERE</code> <code class="sql plain">(addresses.client_id </code><code class="sql color1">IN</code> <code class="sql plain">(1,2,3,4,5,6,7,8,9,10))</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="eager-loading-multiple-associations">13.1 Eager Loading Multiple Associations</h4><p>Active Record lets you eager load any number of associations with a single <code>Model.find</code> call by using an array, hash, or a nested hash of array/hash with the <code>includes</code> method.</p><h5 id="array-of-multiple-associations">13.1.1 Array of Multiple Associations</h5><div class="code_container">
<div><div id="highlighter_259299" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.includes(</code><code class="ruby color2">:category</code><code class="ruby plain">, </code><code class="ruby color2">:comments</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This loads all the articles and the associated category and comments for each article.</p><h5 id="nested-associations-hash">13.1.2 Nested Associations Hash</h5><div class="code_container">
<div><div id="highlighter_990691" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Category.includes(articles: [{ comments: </code><code class="ruby color2">:guest</code> <code class="ruby plain">}, </code><code class="ruby color2">:tags</code><code class="ruby plain">]).find(</code><code class="ruby constants">1</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This will find the category with id 1 and eager load all of the 
associated articles, the associated articles' tags and comments, and 
every comment's guest association.</p><h4 id="specifying-conditions-on-eager-loaded-associations">13.2 Specifying Conditions on Eager Loaded Associations</h4><p>Even though Active Record lets you specify conditions on the eager loaded associations just like <code>joins</code>, the recommended way is to use <a href="#joining-tables">joins</a> instead.</p><p>However if you must do this, you may use <code>where</code> as you would normally.</p><div class="code_container">
<div><div id="highlighter_667647" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.includes(</code><code class="ruby color2">:comments</code><code class="ruby plain">).where(comments: { visible: </code><code class="ruby keyword">true</code> <code class="ruby plain">})</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This would generate a query which contains a <code>LEFT OUTER JOIN</code> whereas the
<code>joins</code> method would generate one using the <code>INNER JOIN</code> function instead.</p><div class="code_container">
<div><div id="highlighter_763265" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby constants">SELECT</code> <code class="ruby string">"articles"</code><code class="ruby plain">.</code><code class="ruby string">"id"</code> <code class="ruby constants">AS</code> <code class="ruby plain">t0_r0, ... </code><code class="ruby string">"comments"</code><code class="ruby plain">.</code><code class="ruby string">"updated_at"</code> <code class="ruby constants">AS</code> <code class="ruby plain">t1_r5 </code><code class="ruby constants">FROM</code> <code class="ruby string">"articles"</code> <code class="ruby constants">LEFT</code> <code class="ruby constants">OUTER</code> <code class="ruby constants">JOIN</code> <code class="ruby string">"comments"</code> <code class="ruby constants">ON</code> <code class="ruby string">"comments"</code><code class="ruby plain">.</code><code class="ruby string">"article_id"</code> <code class="ruby plain">= </code><code class="ruby string">"articles"</code><code class="ruby plain">.</code><code class="ruby string">"id"</code> <code class="ruby constants">WHERE</code> <code class="ruby plain">(comments.visible = </code><code class="ruby constants">1</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>If there was no <code>where</code> condition, this would generate the normal set of two queries.</p><div class="note"><p>Using <code>where</code> like this will only work when you pass it a Hash. For
SQL-fragments you need to use <code>references</code> to force joined tables:</p></div><div class="code_container">
<div><div id="highlighter_84247" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.includes(</code><code class="ruby color2">:comments</code><code class="ruby plain">).where(</code><code class="ruby string">"comments.visible = true"</code><code class="ruby plain">).references(</code><code class="ruby color2">:comments</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>If, in the case of this <code>includes</code> query, there were no comments for any
articles, all the articles would still be loaded. By using <code>joins</code> (an INNER
JOIN), the join conditions <strong>must</strong> match, otherwise no records will be
returned.</p><h3 id="scopes">14 Scopes</h3><p>Scoping allows you to 
specify commonly-used queries which can be referenced as method calls on
 the association objects or models. With these scopes, you can use every
 method previously covered such as <code>where</code>, <code>joins</code> and <code>includes</code>. All scope methods will return an <code>ActiveRecord::Relation</code> object which will allow for further methods (such as other scopes) to be called on it.</p><p>To define a simple scope, we use the <code>scope</code> method inside the class, passing the query that we'd like to run when this scope is called:</p><div class="code_container">
<div><div id="highlighter_126693" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Article &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:published</code><code class="ruby plain">, -&gt; { where(published: </code><code class="ruby keyword">true</code><code class="ruby plain">) }</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This is exactly the same as defining a class method, and which you use is a matter of personal preference:</p><div class="code_container">
<div><div id="highlighter_943631" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Article &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">def</code> <code class="ruby keyword">self</code><code class="ruby plain">.published</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="ruby plain">where(published: </code><code class="ruby keyword">true</code><code class="ruby plain">)</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">end</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Scopes are also chainable within scopes:</p><div class="code_container">
<div><div id="highlighter_193424" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Article &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:published</code><code class="ruby plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; { where(published: </code><code class="ruby keyword">true</code><code class="ruby plain">) }</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:published_and_commented</code><code class="ruby plain">, -&gt; { published.where(</code><code class="ruby string">"comments_count &gt; 0"</code><code class="ruby plain">) }</code></div><div class="line number4 index3 alt1"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>To call this <code>published</code> scope we can call it on either the class:</p><div class="code_container">
<div><div id="highlighter_514368" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.published </code><code class="ruby comments"># =&gt; [published articles]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Or on an association consisting of <code>Article</code> objects:</p><div class="code_container">
<div><div id="highlighter_907968" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">category = Category.first</code></div><div class="line number2 index1 alt1"><code class="ruby plain">category.articles.published </code><code class="ruby comments"># =&gt; [published articles belonging to this category]</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="passing-in-arguments">14.1 Passing in arguments</h4><p>Your scope can take arguments:</p><div class="code_container">
<div><div id="highlighter_515497" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Article &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:created_before</code><code class="ruby plain">, -&gt;(time) { where(</code><code class="ruby string">"created_at &lt; ?"</code><code class="ruby plain">, time) }</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Call the scope as if it were a class method:</p><div class="code_container">
<div><div id="highlighter_405796" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Article.created_before(</code><code class="ruby color1">Time</code><code class="ruby plain">.zone.now)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>However, this is just duplicating the functionality that would be provided to you by a class method.</p><div class="code_container">
<div><div id="highlighter_436831" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Article &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">def</code> <code class="ruby keyword">self</code><code class="ruby plain">.created_before(time)</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="ruby plain">where(</code><code class="ruby string">"created_at &lt; ?"</code><code class="ruby plain">, time)</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">end</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Using a class method is the preferred way to accept arguments for 
scopes. These methods will still be accessible on the association 
objects:</p><div class="code_container">
<div><div id="highlighter_651713" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">category.articles.created_before(time)</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="applying-a-default-scope">14.2 Applying a default scope</h4><p>If we wish for a scope to be applied across all queries to the model we can use the
<code>default_scope</code> method within the model itself.</p><div class="code_container">
<div><div id="highlighter_882509" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Client &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">default_scope { where(</code><code class="ruby string">"removed_at IS NULL"</code><code class="ruby plain">) }</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>When queries are executed on this model, the SQL query will now look something like
this:</p><div class="code_container">
<div><div id="highlighter_2989" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">removed_at </code><code class="sql keyword">IS</code> <code class="sql color1">NULL</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>If you need to do more complex things with a default scope, you can alternatively
define it as a class method:</p><div class="code_container">
<div><div id="highlighter_104239" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Client &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">def</code> <code class="ruby keyword">self</code><code class="ruby plain">.default_scope</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="ruby comments"># Should return an ActiveRecord::Relation.</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">end</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="merging-of-scopes">14.3 Merging of scopes</h4><p>Just like <code>where</code> clauses scopes are merged using <code>AND</code> conditions.</p><div class="code_container">
<div><div id="highlighter_770665" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">User &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:active</code><code class="ruby plain">, -&gt; { where state: </code><code class="ruby string">'active'</code> <code class="ruby plain">}</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:inactive</code><code class="ruby plain">, -&gt; { where state: </code><code class="ruby string">'inactive'</code> <code class="ruby plain">}</code></div><div class="line number4 index3 alt1"><code class="ruby keyword">end</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="ruby plain">User.active.inactive</code></div><div class="line number7 index6 alt2"><code class="ruby comments"># SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>We can mix and match <code>scope</code> and <code>where</code> conditions and the final sql
will have all conditions joined with <code>AND</code>.</p><div class="code_container">
<div><div id="highlighter_910899" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.active.where(state: </code><code class="ruby string">'finished'</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>If we do want the last <code>where</code> clause to win then <code>Relation#merge</code> can
be used.</p><div class="code_container">
<div><div id="highlighter_743342" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.active.merge(User.inactive)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>One important caveat is that <code>default_scope</code> will be prepended in
<code>scope</code> and <code>where</code> conditions.</p><div class="code_container">
<div><div id="highlighter_276927" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">User &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">default_scope { where state: </code><code class="ruby string">'pending'</code> <code class="ruby plain">}</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:active</code><code class="ruby plain">, -&gt; { where state: </code><code class="ruby string">'active'</code> <code class="ruby plain">}</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">scope </code><code class="ruby color2">:inactive</code><code class="ruby plain">, -&gt; { where state: </code><code class="ruby string">'inactive'</code> <code class="ruby plain">}</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="ruby plain">User.all</code></div><div class="line number8 index7 alt1"><code class="ruby comments"># SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="ruby plain">User.active</code></div><div class="line number11 index10 alt2"><code class="ruby comments"># SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="ruby plain">User.where(state: </code><code class="ruby string">'inactive'</code><code class="ruby plain">)</code></div><div class="line number14 index13 alt1"><code class="ruby comments"># SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>As you can see above the <code>default_scope</code> is being merged in both
<code>scope</code> and <code>where</code> conditions.</p><h4 id="removing-all-scoping">14.4 Removing All Scoping</h4><p>If we wish to remove scoping for any reason we can use the <code>unscoped</code> method. This is
especially useful if a <code>default_scope</code> is specified in the model and should not be
applied for this particular query.</p><div class="code_container">
<div><div id="highlighter_441471" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.unscoped.load</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This method removes all scoping and will do a normal query on the table.</p><p>Note that chaining <code>unscoped</code> with a <code>scope</code> does not work. In these cases, it is
recommended that you use the block form of <code>unscoped</code>:</p><div class="code_container">
<div><div id="highlighter_993723" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.unscoped {</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">Client.created_before(</code><code class="ruby color1">Time</code><code class="ruby plain">.zone.now)</code></div><div class="line number3 index2 alt2"><code class="ruby plain">}</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="dynamic-finders">15 Dynamic Finders</h3><p>For every field (also
 known as an attribute) you define in your table, Active Record provides
 a finder method. If you have a field called <code>first_name</code> on your <code>Client</code> model for example, you get <code>find_by_first_name</code> for free from Active Record. If you have a <code>locked</code> field on the <code>Client</code> model, you also get <code>find_by_locked</code> method.</p><p>You can specify an exclamation point (<code>!</code>) on the end of the dynamic finders to get them to raise an <code>ActiveRecord::RecordNotFound</code> error if they do not return any records, like <code>Client.find_by_name!("Ryan")</code></p><p>If you want to find both by name and locked, you can chain these finders together by simply typing "<code>and</code>" between the fields. For example, <code>Client.find_by_first_name_and_locked("Ryan", true)</code>.</p><h3 id="understanding-the-method-chaining">16 Understanding The Method Chaining</h3><p>The Active Record pattern implements <a href="http://en.wikipedia.org/wiki/Method_chaining">Method Chaining</a>,
which allow us to use multiple Active Record methods together in a simple and straightforward way.</p><p>You can chain methods in a statement when the previous method called returns an
<code>ActiveRecord::Relation</code>, like <code>all</code>, <code>where</code>, and <code>joins</code>. Methods that return
a single object (see <a href="#retrieving-a-single-object">Retrieving a Single Object Section</a>)
have to be at the end of the statement.</p><p>There are some examples below. This guide won't cover all the possibilities, just a few as examples.
When an Active Record method is called, the query is not immediately generated and sent to the database,
this just happens when the data is actually needed. So each example below generates a single query.</p><h4 id="retrieving-filtered-data-from-multiple-tables">16.1 Retrieving filtered data from multiple tables</h4><div class="code_container">
<div><div id="highlighter_990197" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Person</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">.select(</code><code class="ruby string">'people.id, people.name, comments.text'</code><code class="ruby plain">)</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">.joins(</code><code class="ruby color2">:comments</code><code class="ruby plain">)</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">.where(</code><code class="ruby string">'comments.created_at &gt; ?'</code><code class="ruby plain">, </code><code class="ruby constants">1</code><code class="ruby plain">.week.ago)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The result should be something like this:</p><div class="code_container">
<div><div id="highlighter_464804" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">people.id, people.</code><code class="sql keyword">name</code><code class="sql plain">, comments.text</code></div><div class="line number2 index1 alt1"><code class="sql keyword">FROM</code> <code class="sql plain">people</code></div><div class="line number3 index2 alt2"><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">comments</code></div><div class="line number4 index3 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">ON</code> <code class="sql plain">comments.person_id = people.id</code></div><div class="line number5 index4 alt2"><code class="sql keyword">WHERE</code> <code class="sql plain">comments.created_at = </code><code class="sql string">'2015-01-01'</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="retrieving-specific-data-from-multiple-tables">16.2 Retrieving specific data from multiple tables</h4><div class="code_container">
<div><div id="highlighter_541433" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Person</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">.select(</code><code class="ruby string">'people.id, people.name, companies.name'</code><code class="ruby plain">)</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">.joins(</code><code class="ruby color2">:company</code><code class="ruby plain">)</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">.find_by(</code><code class="ruby string">'people.name'</code> <code class="ruby plain">=&gt; </code><code class="ruby string">'John'</code><code class="ruby plain">) </code><code class="ruby comments"># this should be the last</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The above should generate:</p><div class="code_container">
<div><div id="highlighter_413352" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">people.id, people.</code><code class="sql keyword">name</code><code class="sql plain">, companies.</code><code class="sql keyword">name</code></div><div class="line number2 index1 alt1"><code class="sql keyword">FROM</code> <code class="sql plain">people</code></div><div class="line number3 index2 alt2"><code class="sql keyword">INNER</code> <code class="sql color1">JOIN</code> <code class="sql plain">companies</code></div><div class="line number4 index3 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql keyword">ON</code> <code class="sql plain">companies.person_id = people.id</code></div><div class="line number5 index4 alt2"><code class="sql keyword">WHERE</code> <code class="sql plain">people.</code><code class="sql keyword">name</code> <code class="sql plain">= </code><code class="sql string">'John'</code></div><div class="line number6 index5 alt1"><code class="sql plain">LIMIT 1</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="note"><p>Note that if a query matches multiple records, <code>find_by</code> will
fetch only the first one and ignore the others (see the <code>LIMIT 1</code>
statement above).</p></div><h3 id="find-or-build-a-new-object">17 Find or Build a New Object</h3><p>It's common that you need to find a record or create it if it doesn't exist. You can do that with the <code>find_or_create_by</code> and <code>find_or_create_by!</code> methods.</p><h4 id="find-or-create-by">17.1 <code>find_or_create_by</code>
</h4><p>The <code>find_or_create_by</code> method checks whether a record with the attributes exists. If it doesn't, then <code>create</code> is called. Let's see an example.</p><p>Suppose you want to find a client named 'Andy', and if there's none, create one. You can do so by running:</p><div class="code_container">
<div><div id="highlighter_200729" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.find_or_create_by(first_name: </code><code class="ruby string">'Andy'</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; #&lt;Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The SQL generated by this method looks like this:</p><div class="code_container">
<div><div id="highlighter_605059" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">(clients.first_name = </code><code class="sql string">'Andy'</code><code class="sql plain">) LIMIT 1</code></div><div class="line number2 index1 alt1"><code class="sql keyword">BEGIN</code></div><div class="line number3 index2 alt2"><code class="sql keyword">INSERT</code> <code class="sql keyword">INTO</code> <code class="sql plain">clients (created_at, first_name, locked, orders_count, updated_at) </code><code class="sql keyword">VALUES</code> <code class="sql plain">(</code><code class="sql string">'2011-08-30 05:22:57'</code><code class="sql plain">, </code><code class="sql string">'Andy'</code><code class="sql plain">, 1, </code><code class="sql color1">NULL</code><code class="sql plain">, </code><code class="sql string">'2011-08-30 05:22:57'</code><code class="sql plain">)</code></div><div class="line number4 index3 alt1"><code class="sql keyword">COMMIT</code></div></div></td></tr></tbody></table></div></div>
</div>
<p><code>find_or_create_by</code> returns either the record that already
 exists or the new record. In our case, we didn't already have a client 
named Andy so the record is created and returned.</p><p>The new record might not be saved to the database; that depends on whether validations passed or not (just like <code>create</code>).</p><p>Suppose we want to set the 'locked' attribute to <code>false</code> if we're
creating a new record, but we don't want to include it in the query. So
we want to find the client named "Andy", or if that client doesn't
exist, create a client named "Andy" which is not locked.</p><p>We can achieve this in two ways. The first is to use <code>create_with</code>:</p><div class="code_container">
<div><div id="highlighter_184346" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.create_with(locked: </code><code class="ruby keyword">false</code><code class="ruby plain">).find_or_create_by(first_name: </code><code class="ruby string">'Andy'</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The second way is using a block:</p><div class="code_container">
<div><div id="highlighter_272736" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.find_or_create_by(first_name: </code><code class="ruby string">'Andy'</code><code class="ruby plain">) </code><code class="ruby keyword">do</code> <code class="ruby plain">|c|</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">c.locked = </code><code class="ruby keyword">false</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The block will only be executed if the client is being created. The
second time we run this code, the block will be ignored.</p><h4 id="find-or-create-by-bang">17.2 <code>find_or_create_by!</code>
</h4><p>You can also use <code>find_or_create_by!</code> to raise an 
exception if the new record is invalid. Validations are not covered on 
this guide, but let's assume for a moment that you temporarily add</p><div class="code_container">
<div><div id="highlighter_162506" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">validates </code><code class="ruby color2">:orders_count</code><code class="ruby plain">, presence: </code><code class="ruby keyword">true</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>to your <code>Client</code> model. If you try to create a new <code>Client</code> without passing an <code>orders_count</code>, the record will be invalid and an exception will be raised:</p><div class="code_container">
<div><div id="highlighter_423214" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.find_or_create_by!(first_name: </code><code class="ruby string">'Andy'</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="find-or-initialize-by">17.3 <code>find_or_initialize_by</code>
</h4><p>The <code>find_or_initialize_by</code> method will work just like
<code>find_or_create_by</code> but it will call <code>new</code> instead of <code>create</code>. This
means that a new model instance will be created in memory but won't be
saved to the database. Continuing with the <code>find_or_create_by</code> example, we
now want the client named 'Nick':</p><div class="code_container">
<div><div id="highlighter_355076" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">nick = Client.find_or_initialize_by(first_name: </code><code class="ruby string">'Nick'</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; &lt;Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="ruby plain">nick.persisted?</code></div><div class="line number5 index4 alt2"><code class="ruby comments"># =&gt; false</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="ruby plain">nick.new_record?</code></div><div class="line number8 index7 alt1"><code class="ruby comments"># =&gt; true</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Because the object is not yet stored in the database, the SQL generated looks like this:</p><div class="code_container">
<div><div id="highlighter_600791" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql plain">* </code><code class="sql keyword">FROM</code> <code class="sql plain">clients </code><code class="sql keyword">WHERE</code> <code class="sql plain">(clients.first_name = </code><code class="sql string">'Nick'</code><code class="sql plain">) LIMIT 1</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>When you want to save it to the database, just call <code>save</code>:</p><div class="code_container">
<div><div id="highlighter_307997" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">nick.save</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; true</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="finding-by-sql">18 Finding by SQL</h3><p>If you'd like to use your own SQL to find records in a table you can use <code>find_by_sql</code>. The <code>find_by_sql</code>
 method will return an array of objects even if the underlying query 
returns just a single record. For example you could run this query:</p><div class="code_container">
<div><div id="highlighter_542362" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.find_by_sql("</code><code class="ruby constants">SELECT</code> <code class="ruby plain">* </code><code class="ruby constants">FROM</code> <code class="ruby plain">clients</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby constants">INNER</code> <code class="ruby constants">JOIN</code> <code class="ruby plain">orders </code><code class="ruby constants">ON</code> <code class="ruby plain">clients.id = orders.client_id</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby constants">ORDER</code> <code class="ruby constants">BY</code> <code class="ruby plain">clients.created_at desc")</code></div><div class="line number4 index3 alt1"><code class="ruby comments"># =&gt;&nbsp; [</code></div><div class="line number5 index4 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 1, first_name: "Lucas" &gt;,</code></div><div class="line number6 index5 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments">#&lt;Client id: 2, first_name: "Jan" &gt;,</code></div><div class="line number7 index6 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby comments"># ...</code></div><div class="line number8 index7 alt1"><code class="ruby plain">]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p><code>find_by_sql</code> provides you with a simple way of making custom calls to the database and retrieving instantiated objects.</p><h4 id="select-all">18.1 <code>select_all</code>
</h4><p><code>find_by_sql</code> has a close relative called <code>connection#select_all</code>. <code>select_all</code> will retrieve objects from the database using custom SQL just like <code>find_by_sql</code> but will not instantiate them. Instead, you will get an array of hashes where each hash indicates a record.</p><div class="code_container">
<div><div id="highlighter_467762" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.connection.select_all(</code><code class="ruby string">"SELECT first_name, created_at FROM clients WHERE id = '1'"</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; [</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">{</code><code class="ruby string">"first_name"</code><code class="ruby plain">=&gt;</code><code class="ruby string">"Rafael"</code><code class="ruby plain">, </code><code class="ruby string">"created_at"</code><code class="ruby plain">=&gt;</code><code class="ruby string">"2012-11-10 23:23:45.281189"</code><code class="ruby plain">},</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby plain">{</code><code class="ruby string">"first_name"</code><code class="ruby plain">=&gt;</code><code class="ruby string">"Eileen"</code><code class="ruby plain">, </code><code class="ruby string">"created_at"</code><code class="ruby plain">=&gt;</code><code class="ruby string">"2013-12-09 11:22:35.221282"</code><code class="ruby plain">}</code></div><div class="line number5 index4 alt2"><code class="ruby plain">]</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="pluck">18.2 <code>pluck</code>
</h4><p><code>pluck</code> can be used to query single or multiple 
columns from the underlying table of a model. It accepts a list of 
column names as argument and returns an array of values of the specified
 columns with the corresponding data type.</p><div class="code_container">
<div><div id="highlighter_882824" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(active: </code><code class="ruby keyword">true</code><code class="ruby plain">).pluck(</code><code class="ruby color2">:id</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT id FROM clients WHERE active = 1</code></div><div class="line number3 index2 alt2"><code class="ruby comments"># =&gt; [1, 2, 3]</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="ruby plain">Client.distinct.pluck(</code><code class="ruby color2">:role</code><code class="ruby plain">)</code></div><div class="line number6 index5 alt1"><code class="ruby comments"># SELECT DISTINCT role FROM clients</code></div><div class="line number7 index6 alt2"><code class="ruby comments"># =&gt; ['admin', 'member', 'guest']</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="ruby plain">Client.pluck(</code><code class="ruby color2">:id</code><code class="ruby plain">, </code><code class="ruby color2">:name</code><code class="ruby plain">)</code></div><div class="line number10 index9 alt1"><code class="ruby comments"># SELECT clients.id, clients.name FROM clients</code></div><div class="line number11 index10 alt2"><code class="ruby comments"># =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p><code>pluck</code> makes it possible to replace code like:</p><div class="code_container">
<div><div id="highlighter_715591" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.select(</code><code class="ruby color2">:id</code><code class="ruby plain">).map { |c| c.id }</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># or</code></div><div class="line number3 index2 alt2"><code class="ruby plain">Client.select(</code><code class="ruby color2">:id</code><code class="ruby plain">).map(&amp;</code><code class="ruby color2">:id</code><code class="ruby plain">)</code></div><div class="line number4 index3 alt1"><code class="ruby comments"># or</code></div><div class="line number5 index4 alt2"><code class="ruby plain">Client.select(</code><code class="ruby color2">:id</code><code class="ruby plain">, </code><code class="ruby color2">:name</code><code class="ruby plain">).map { |c| [c.id, c.name] }</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>with:</p><div class="code_container">
<div><div id="highlighter_129074" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.pluck(</code><code class="ruby color2">:id</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># or</code></div><div class="line number3 index2 alt2"><code class="ruby plain">Client.pluck(</code><code class="ruby color2">:id</code><code class="ruby plain">, </code><code class="ruby color2">:name</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Unlike <code>select</code>, <code>pluck</code> directly converts a database result into a Ruby <code>Array</code>,
without constructing <code>ActiveRecord</code> objects. This can mean better performance for
a large or often-running query. However, any model method overrides will
not be available. For example:</p><div class="code_container">
<div><div id="highlighter_153925" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Client &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">def</code> <code class="ruby plain">name</code></div><div class="line number3 index2 alt2"><code class="ruby spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="ruby string">"I am #{super}"</code></div><div class="line number4 index3 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">end</code></div><div class="line number5 index4 alt2"><code class="ruby keyword">end</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="ruby plain">Client.select(</code><code class="ruby color2">:name</code><code class="ruby plain">).map &amp;</code><code class="ruby color2">:name</code></div><div class="line number8 index7 alt1"><code class="ruby comments"># =&gt; ["I am David", "I am Jeremy", "I am Jose"]</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="ruby plain">Client.pluck(</code><code class="ruby color2">:name</code><code class="ruby plain">)</code></div><div class="line number11 index10 alt2"><code class="ruby comments"># =&gt; ["David", "Jeremy", "Jose"]</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Furthermore, unlike <code>select</code> and other <code>Relation</code> scopes, <code>pluck</code> triggers an immediate
query, and thus cannot be chained with any further scopes, although it can work with
scopes already constructed earlier:</p><div class="code_container">
<div><div id="highlighter_318610" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.pluck(</code><code class="ruby color2">:name</code><code class="ruby plain">).limit(</code><code class="ruby constants">1</code><code class="ruby plain">)</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># =&gt; NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="ruby plain">Client.limit(</code><code class="ruby constants">1</code><code class="ruby plain">).pluck(</code><code class="ruby color2">:name</code><code class="ruby plain">)</code></div><div class="line number5 index4 alt2"><code class="ruby comments"># =&gt; ["David"]</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="ids">18.3 <code>ids</code>
</h4><p><code>ids</code> can be used to pluck all the IDs for the relation using the table's primary key.</p><div class="code_container">
<div><div id="highlighter_340240" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Person.ids</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT id FROM people</code></div></div></td></tr></tbody></table></div></div>
</div>
<div class="code_container">
<div><div id="highlighter_494353" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby keyword">class</code> <code class="ruby plain">Person &lt; ActiveRecord::Base</code></div><div class="line number2 index1 alt1"><code class="ruby spaces">&nbsp;&nbsp;</code><code class="ruby keyword">self</code><code class="ruby plain">.primary_key = </code><code class="ruby string">"person_id"</code></div><div class="line number3 index2 alt2"><code class="ruby keyword">end</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="ruby plain">Person.ids</code></div><div class="line number6 index5 alt1"><code class="ruby comments"># SELECT person_id FROM people</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="existence-of-objects">19 Existence of Objects</h3><p>If you simply want to check for the existence of the object there's a method called <code>exists?</code>.
This method will query the database using the same query as <code>find</code>, but instead of returning an
object or collection of objects it will return either <code>true</code> or <code>false</code>.</p><div class="code_container">
<div><div id="highlighter_224496" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.exists?(</code><code class="ruby constants">1</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The <code>exists?</code> method also takes multiple values, but the catch is that it will return <code>true</code> if any
one of those records exists.</p><div class="code_container">
<div><div id="highlighter_568798" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.exists?(id: [</code><code class="ruby constants">1</code><code class="ruby plain">,</code><code class="ruby constants">2</code><code class="ruby plain">,</code><code class="ruby constants">3</code><code class="ruby plain">])</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># or</code></div><div class="line number3 index2 alt2"><code class="ruby plain">Client.exists?(name: [</code><code class="ruby string">'John'</code><code class="ruby plain">, </code><code class="ruby string">'Sergei'</code><code class="ruby plain">])</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>It's even possible to use <code>exists?</code> without any arguments on a model or a relation.</p><div class="code_container">
<div><div id="highlighter_607665" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(first_name: </code><code class="ruby string">'Ryan'</code><code class="ruby plain">).exists?</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The above returns <code>true</code> if there is at least one client with the <code>first_name</code> 'Ryan' and <code>false</code>
otherwise.</p><div class="code_container">
<div><div id="highlighter_604107" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.exists?</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>The above returns <code>false</code> if the <code>clients</code> table is empty and <code>true</code> otherwise.</p><p>You can also use <code>any?</code> and <code>many?</code> to check for existence on a model or relation.</p><div class="code_container">
<div><div id="highlighter_543715" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby comments"># via a model</code></div><div class="line number2 index1 alt1"><code class="ruby plain">Article.any?</code></div><div class="line number3 index2 alt2"><code class="ruby plain">Article.many?</code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="ruby comments"># via a named scope</code></div><div class="line number6 index5 alt1"><code class="ruby plain">Article.recent.any?</code></div><div class="line number7 index6 alt2"><code class="ruby plain">Article.recent.many?</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="ruby comments"># via a relation</code></div><div class="line number10 index9 alt1"><code class="ruby plain">Article.where(published: </code><code class="ruby keyword">true</code><code class="ruby plain">).any?</code></div><div class="line number11 index10 alt2"><code class="ruby plain">Article.where(published: </code><code class="ruby keyword">true</code><code class="ruby plain">).many?</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="ruby comments"># via an association</code></div><div class="line number14 index13 alt1"><code class="ruby plain">Article.first.categories.any?</code></div><div class="line number15 index14 alt2"><code class="ruby plain">Article.first.categories.many?</code></div></div></td></tr></tbody></table></div></div>
</div>
<h3 id="calculations">20 Calculations</h3><p>This section uses count as an example method in this preamble, but the options described apply to all sub-sections.</p><p>All calculation methods work directly on a model:</p><div class="code_container">
<div><div id="highlighter_614534" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.count</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT count(*) AS count_all FROM clients</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Or on a relation:</p><div class="code_container">
<div><div id="highlighter_753155" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.where(first_name: </code><code class="ruby string">'Ryan'</code><code class="ruby plain">).count</code></div><div class="line number2 index1 alt1"><code class="ruby comments"># SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>You can also use various finder methods on a relation for performing complex calculations:</p><div class="code_container">
<div><div id="highlighter_896060" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.includes(</code><code class="ruby string">"orders"</code><code class="ruby plain">).where(first_name: </code><code class="ruby string">'Ryan'</code><code class="ruby plain">, orders: { status: </code><code class="ruby string">'received'</code> <code class="ruby plain">}).count</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Which will execute:</p><div class="code_container">
<div><div id="highlighter_503019" class="syntaxhighlighter nogutter  sql"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="sql keyword">SELECT</code> <code class="sql color2">count</code><code class="sql plain">(</code><code class="sql keyword">DISTINCT</code> <code class="sql plain">clients.id) </code><code class="sql keyword">AS</code> <code class="sql plain">count_all </code><code class="sql keyword">FROM</code> <code class="sql plain">clients</code></div><div class="line number2 index1 alt1"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql color2">LEFT</code> <code class="sql color1">OUTER</code> <code class="sql color1">JOIN</code> <code class="sql plain">orders </code><code class="sql keyword">ON</code> <code class="sql plain">orders.client_id = client.id </code><code class="sql keyword">WHERE</code></div><div class="line number3 index2 alt2"><code class="sql spaces">&nbsp;&nbsp;</code><code class="sql plain">(clients.first_name = </code><code class="sql string">'Ryan'</code> <code class="sql color1">AND</code> <code class="sql plain">orders.status = </code><code class="sql string">'received'</code><code class="sql plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<h4 id="count">20.1 Count</h4><p>If you want to see how many records are in your model's table you could call <code>Client.count</code>
 and that will return the number. If you want to be more specific and 
find all the clients with their age present in the database you can use <code>Client.count(:age)</code>.</p><p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p><h4 id="average">20.2 Average</h4><p>If you want to see the average of a certain number in one of your tables you can call the <code>average</code> method on the class that relates to the table. This method call will look something like this:</p><div class="code_container">
<div><div id="highlighter_625724" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.average(</code><code class="ruby string">"orders_count"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>This will return a number (possibly a floating point number such as 3.14159265) representing the average value in the field.</p><p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p><h4 id="minimum">20.3 Minimum</h4><p>If you want to find the minimum value of a field in your table you can call the <code>minimum</code> method on the class that relates to the table. This method call will look something like this:</p><div class="code_container">
<div><div id="highlighter_189267" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.minimum(</code><code class="ruby string">"age"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p><h4 id="maximum">20.4 Maximum</h4><p>If you want to find the maximum value of a field in your table you can call the <code>maximum</code> method on the class that relates to the table. This method call will look something like this:</p><div class="code_container">
<div><div id="highlighter_148569" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.maximum(</code><code class="ruby string">"age"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p><h4 id="sum">20.5 Sum</h4><p>If you want to find the sum of a field for all records in your table you can call the <code>sum</code> method on the class that relates to the table. This method call will look something like this:</p><div class="code_container">
<div><div id="highlighter_889530" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">Client.sum(</code><code class="ruby string">"orders_count"</code><code class="ruby plain">)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p><h3 id="running-explain">21 Running EXPLAIN</h3><p>You can run EXPLAIN on the queries triggered by relations. For example,</p><div class="code_container">
<div><div id="highlighter_410124" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.where(id: </code><code class="ruby constants">1</code><code class="ruby plain">).joins(</code><code class="ruby color2">:articles</code><code class="ruby plain">).explain</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>may yield</p><div class="code_container">
<div><div id="highlighter_746345" class="syntaxhighlighter nogutter  plain"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain plain">EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1</code></div><div class="line number2 index1 alt1"><code class="plain plain">+----+-------------+----------+-------+---------------+</code></div><div class="line number3 index2 alt2"><code class="plain plain">| id | select_type | table&nbsp;&nbsp;&nbsp; | type&nbsp; | possible_keys |</code></div><div class="line number4 index3 alt1"><code class="plain plain">+----+-------------+----------+-------+---------------+</code></div><div class="line number5 index4 alt2"><code class="plain plain">|&nbsp; 1 | SIMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | users&nbsp;&nbsp;&nbsp; | const | PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number6 index5 alt1"><code class="plain plain">|&nbsp; 1 | SIMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | articles | ALL&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number7 index6 alt2"><code class="plain plain">+----+-------------+----------+-------+---------------+</code></div><div class="line number8 index7 alt1"><code class="plain plain">+---------+---------+-------+------+-------------+</code></div><div class="line number9 index8 alt2"><code class="plain plain">| key&nbsp;&nbsp;&nbsp;&nbsp; | key_len | ref&nbsp;&nbsp; | rows | Extra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number10 index9 alt1"><code class="plain plain">+---------+---------+-------+------+-------------+</code></div><div class="line number11 index10 alt2"><code class="plain plain">| PRIMARY | 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | const |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number12 index11 alt1"><code class="plain plain">| NULL&nbsp;&nbsp;&nbsp; | NULL&nbsp;&nbsp;&nbsp; | NULL&nbsp; |&nbsp;&nbsp;&nbsp; 1 | Using where |</code></div><div class="line number13 index12 alt2"><code class="plain plain">+---------+---------+-------+------+-------------+</code></div><div class="line number14 index13 alt1">&nbsp;</div><div class="line number15 index14 alt2"><code class="plain plain">2 rows in set (0.00 sec)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>under MySQL.</p><p>Active Record performs a pretty printing that emulates that of the
corresponding database shell. So, the same query running with the
PostgreSQL adapter would yield instead</p><div class="code_container">
<div><div id="highlighter_401793" class="syntaxhighlighter nogutter  plain"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain plain">EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1</code></div><div class="line number2 index1 alt1"><code class="plain spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain plain">QUERY PLAN</code></div><div class="line number3 index2 alt2"><code class="plain plain">------------------------------------------------------------------------------</code></div><div class="line number4 index3 alt1"><code class="plain spaces">&nbsp;</code><code class="plain plain">Nested Loop Left Join&nbsp; (cost=0.00..37.24 rows=8 width=0)</code></div><div class="line number5 index4 alt2"><code class="plain spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain plain">Join Filter: (articles.user_id = users.id)</code></div><div class="line number6 index5 alt1"><code class="plain spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain plain">-&gt;&nbsp; Index Scan using users_pkey on users&nbsp; (cost=0.00..8.27 rows=1 width=4)</code></div><div class="line number7 index6 alt2"><code class="plain spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain plain">Index Cond: (id = 1)</code></div><div class="line number8 index7 alt1"><code class="plain spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain plain">-&gt;&nbsp; Seq Scan on articles&nbsp; (cost=0.00..28.88 rows=8 width=4)</code></div><div class="line number9 index8 alt2"><code class="plain spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain plain">Filter: (articles.user_id = 1)</code></div><div class="line number10 index9 alt1"><code class="plain plain">(6 rows)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>Eager loading may trigger more than one query under the hood, and some queries
may need the results of previous ones. Because of that, <code>explain</code> actually
executes the query, and then asks for the query plans. For example,</p><div class="code_container">
<div><div id="highlighter_206411" class="syntaxhighlighter nogutter  ruby"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="ruby plain">User.where(id: </code><code class="ruby constants">1</code><code class="ruby plain">).includes(</code><code class="ruby color2">:articles</code><code class="ruby plain">).explain</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>yields</p><div class="code_container">
<div><div id="highlighter_98410" class="syntaxhighlighter nogutter  plain"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="plain plain">EXPLAIN for: SELECT `users`.* FROM `users`&nbsp; WHERE `users`.`id` = 1</code></div><div class="line number2 index1 alt1"><code class="plain plain">+----+-------------+-------+-------+---------------+</code></div><div class="line number3 index2 alt2"><code class="plain plain">| id | select_type | table | type&nbsp; | possible_keys |</code></div><div class="line number4 index3 alt1"><code class="plain plain">+----+-------------+-------+-------+---------------+</code></div><div class="line number5 index4 alt2"><code class="plain plain">|&nbsp; 1 | SIMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | users | const | PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number6 index5 alt1"><code class="plain plain">+----+-------------+-------+-------+---------------+</code></div><div class="line number7 index6 alt2"><code class="plain plain">+---------+---------+-------+------+-------+</code></div><div class="line number8 index7 alt1"><code class="plain plain">| key&nbsp;&nbsp;&nbsp;&nbsp; | key_len | ref&nbsp;&nbsp; | rows | Extra |</code></div><div class="line number9 index8 alt2"><code class="plain plain">+---------+---------+-------+------+-------+</code></div><div class="line number10 index9 alt1"><code class="plain plain">| PRIMARY | 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | const |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number11 index10 alt2"><code class="plain plain">+---------+---------+-------+------+-------+</code></div><div class="line number12 index11 alt1">&nbsp;</div><div class="line number13 index12 alt2"><code class="plain plain">1 row in set (0.00 sec)</code></div><div class="line number14 index13 alt1">&nbsp;</div><div class="line number15 index14 alt2"><code class="plain plain">EXPLAIN for: SELECT `articles`.* FROM `articles`&nbsp; WHERE `articles`.`user_id` IN (1)</code></div><div class="line number16 index15 alt1"><code class="plain plain">+----+-------------+----------+------+---------------+</code></div><div class="line number17 index16 alt2"><code class="plain plain">| id | select_type | table&nbsp;&nbsp;&nbsp; | type | possible_keys |</code></div><div class="line number18 index17 alt1"><code class="plain plain">+----+-------------+----------+------+---------------+</code></div><div class="line number19 index18 alt2"><code class="plain plain">|&nbsp; 1 | SIMPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | articles | ALL&nbsp; | NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number20 index19 alt1"><code class="plain plain">+----+-------------+----------+------+---------------+</code></div><div class="line number21 index20 alt2"><code class="plain plain">+------+---------+------+------+-------------+</code></div><div class="line number22 index21 alt1"><code class="plain plain">| key&nbsp; | key_len | ref&nbsp; | rows | Extra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</code></div><div class="line number23 index22 alt2"><code class="plain plain">+------+---------+------+------+-------------+</code></div><div class="line number24 index23 alt1"><code class="plain plain">| NULL | NULL&nbsp;&nbsp;&nbsp; | NULL |&nbsp;&nbsp;&nbsp; 1 | Using where |</code></div><div class="line number25 index24 alt2"><code class="plain plain">+------+---------+------+------+-------------+</code></div><div class="line number26 index25 alt1">&nbsp;</div><div class="line number27 index26 alt2">&nbsp;</div><div class="line number28 index27 alt1"><code class="plain plain">1 row in set (0.00 sec)</code></div></div></td></tr></tbody></table></div></div>
</div>
<p>under MySQL.</p><h4 id="interpreting-explain">21.1 Interpreting EXPLAIN</h4><p>Interpretation of the output of EXPLAIN is beyond the scope of this guide. The
following pointers may be helpful:</p>
<ul>
<li><p>SQLite3: <a href="http://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li>
<li><p>MySQL: <a href="http://dev.mysql.com/doc/refman/5.6/en/explain-output.html">EXPLAIN Output Format</a></p></li>
<li><p>PostgreSQL: <a href="http://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p></li>
</ul>


        <h3>Feedback</h3>
        <p>
          You're encouraged to help improve the quality of this guide.
        </p>
        <p>
          Please contribute if you see any typos or factual errors.
          To get started, you can read our <a href="http://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section.
        </p>
        <p>
          You may also find incomplete content, or stuff that is not up to date.
          Please do add any missing documentation for master. Make sure to check
          <a href="http://edgeguides.rubyonrails.org/">Edge Guides</a> first to verify
          if the issues are already fixed or not on the master branch.
          Check the <a href="http://edgeguides.rubyonrails.org/ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>
          for style and conventions.
        </p>
        <p>
          If for whatever reason you spot something to fix but cannot patch it yourself, please
          <a href="https://github.com/rails/rails/issues">open an issue</a>.
        </p>
        <p>And last but not least, any kind of discussion regarding Ruby on Rails
          documentation is very welcome in the <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs mailing list</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide">
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a> License</p>
<p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>

    </div>
  </div>

  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/jquery.js"></script>
  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/responsive-tables.js"></script>
  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/guides.js"></script>
  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/shCore.js"></script>
  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/shBrushRuby.js"></script>
  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/shBrushXml.js"></script>
  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/shBrushSql.js"></script>
  <script type="text/javascript" src="Active%20Record%20Query%20Interface%20%E2%80%94%20Ruby%20on%20Rails%20Guides_files/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all();
    $(guidesIndex.bind);
  </script>


</body></html>